//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IClient {
    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param programId (optional) 
     * @return Success
     */
    retrieveAllApplicationAttachmentsByProgramApplication(pageIndex: number | undefined, pageSize: number | undefined, programId: number | undefined): Observable<SelectAllApplicationAttachmentsDataPagedModelUsersResult>;
    /**
     * @param applicationAttachmentId (optional) 
     * @return Success
     */
    downloadApplicationAttachmentFile(applicationAttachmentId: number | undefined): Observable<FileResponse>;
    /**
     * @return Success
     */
    fillCertificateTypes(): Observable<ShortFillDataListUsersResult>;
    /**
     * @return Success
     */
    fillCities(): Observable<FillCityDataListUsersResult>;
    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param commissionInvitationId (optional) 
     * @return Success
     */
    retrieveAllCommissionApplicationAttachmentsByCommissionInvitationId(pageIndex: number | undefined, pageSize: number | undefined, commissionInvitationId: number | undefined): Observable<CommissionApplicationAttachmentDataPagedModelUsersResult>;
    /**
     * @param commissionApplicationAttachmentId (optional) 
     * @return Success
     */
    downloadCommissionApplicationAttachmentFile(commissionApplicationAttachmentId: number | undefined): Observable<FileResponse>;
    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param applicationStatusId (optional) 
     * @param programTypeId (optional) 
     * @return Success
     */
    retrieveAllCommissionInvitationsByCommissionId(pageIndex: number | undefined, pageSize: number | undefined, applicationStatusId: number | null | undefined, programTypeId: number | null | undefined): Observable<CommissionInvitationDataPagedModelUsersResult>;
    /**
     * @param commissionInvitationId (optional) 
     * @return Success
     */
    acceptCommissionInvitation(commissionInvitationId: number | undefined): Observable<DbResultInfo>;
    /**
     * @param commissionInvitationId (optional) 
     * @param cancelledDescription (optional) 
     * @param cancelledWithDocuments (optional) 
     * @param fileDescriptions (optional) 
     * @param files (optional) 
     * @return Success
     */
    cancelCommissionInvitation(commissionInvitationId: number | undefined, cancelledDescription: string | null | undefined, cancelledWithDocuments: boolean | undefined, fileDescriptions: string[] | null | undefined, files: FileParameter[] | null | undefined): Observable<DbResultInfo>;
    /**
     * @param commissionInvitationId (optional) 
     * @return Success
     */
    retrieveOneCommissionInvitationById(commissionInvitationId: number | undefined): Observable<SelectOneCommissionInvitationDataUsersResult>;
    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param programId (optional) 
     * @param programTypeId (optional) 
     * @param year (optional) 
     * @return Success
     */
    retrieveAllExamsByCommissionId(pageIndex: number | undefined, pageSize: number | undefined, programId: number | undefined, programTypeId: number | null | undefined, year: number | null | undefined): Observable<SelectAllExamsDataPagedModelUsersResult>;
    /**
     * @param examId (optional) 
     * @return Success
     */
    retrieveOneExamById(examId: number | undefined): Observable<ExamDataUsersResult>;
    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param programId (optional) 
     * @return Success
     */
    retrieveAllExamsByParticipantId(pageIndex: number | undefined, pageSize: number | undefined, programId: number | null | undefined): Observable<SelectAllExamsForParticipantDataPagedModelUsersResult>;
    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param examId (optional) 
     * @return Success
     */
    retrieveAllExamResultsByExamId(pageIndex: number | undefined, pageSize: number | undefined, examId: number | undefined): Observable<SelectAllExamResultsDataPagedModelUsersResult>;
    /**
     * @param examId (optional) 
     * @return Success
     */
    generateExamResultsReport(examId: number | undefined): Observable<FileResponse>;
    /**
     * @return Success
     */
    fillExamTypes(): Observable<ShortFillDataListUsersResult>;
    /**
     * @param searchParam (optional) 
     * @return Success
     */
    fillInstitutions(searchParam: string | null | undefined): Observable<FillDataListUsersResult>;
    /**
     * @return Success
     */
    fillLanguages(): Observable<ShortFillDataListUsersResult>;
    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param trainerInvitationId (optional) 
     * @return Success
     */
    retrieveAllMaterialsByTrainerInvitationId(pageIndex: number | undefined, pageSize: number | undefined, trainerInvitationId: number | undefined): Observable<MaterialDataPagedModelUsersResult>;
    /**
     * @param trainerInvitationId (optional) 
     * @param name (optional) 
     * @param file (optional) 
     * @return Success
     */
    insertMaterial(trainerInvitationId: number | undefined, name: string | null | undefined, file: FileParameter | null | undefined): Observable<InsertIdResultInfo>;
    /**
     * @param materialId (optional) 
     * @return Success
     */
    deleteMaterial(materialId: number | undefined): Observable<DbResultInfo>;
    /**
     * @param materialId (optional) 
     * @return Success
     */
    downloadMaterialFile(materialId: number | undefined): Observable<FileResponse>;
    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param active (optional) 
     * @param programTypeId (optional) 
     * @return Success
     */
    retrieveAllMaterialsByParticipantId(pageIndex: number | undefined, pageSize: number | undefined, active: boolean | null | undefined, programTypeId: number | null | undefined): Observable<SelectAllMaterialsDataPagedModelUsersResult>;
    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    retrieveAllMessageUsersByUserId(pageIndex: number | undefined, pageSize: number | undefined): Observable<SelectAllMessageUsersDataPagedModelUsersResult>;
    /**
     * @return Success
     */
    retrieveAllMessageUsersTotalItems(): Observable<NotificationTotalItemsMessageUserUsersResult>;
    /**
     * @param searchParam (optional) 
     * @return Success
     */
    fillParticipants(searchParam: string | null | undefined): Observable<FillDataListUsersResult>;
    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    retrieveAllParticipantCertificatesByParticipantId(pageIndex: number | undefined, pageSize: number | undefined): Observable<SelectAllParticipantCertificatesDataPagedModelUsersResult>;
    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param institutionName (optional) 
     * @param participantId (optional) 
     * @param issueYear (optional) 
     * @return Success
     */
    retrieveAllCertifiedParticipantsForRegister(pageIndex: number | undefined, pageSize: number | undefined, institutionName: string | null | undefined, participantId: number | null | undefined, issueYear: number | null | undefined): Observable<SelectAllParticipantCertificatesForRegisterDataPagedModelUsersResult>;
    /**
     * @param examId (optional) 
     * @param cancelledDescription (optional) 
     * @param cancelledWithDocuments (optional) 
     * @param fileDescriptions (optional) 
     * @param files (optional) 
     * @return Success
     */
    cancelParticipantExam(examId: number | undefined, cancelledDescription: string | null | undefined, cancelledWithDocuments: boolean | undefined, fileDescriptions: string[] | null | undefined, files: FileParameter[] | null | undefined): Observable<InsertIdResultInfo>;
    /**
     * @param participantExamId (optional) 
     * @return Success
     */
    retrieveOneParticipantExamById(participantExamId: number | undefined): Observable<ParticipantExamDataUsersResult>;
    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param participantExamId (optional) 
     * @return Success
     */
    retrieveAllParticipantExamAttachmentsByParticipantExamId(pageIndex: number | undefined, pageSize: number | undefined, participantExamId: number | undefined): Observable<ParticipantExamAttachmentDataPagedModelUsersResult>;
    /**
     * @param participantExamAttachmentId (optional) 
     * @return Success
     */
    downloadParticipantExamAttachmentFile(participantExamAttachmentId: number | undefined): Observable<FileResponse>;
    /**
     * @return Success
     */
    retrieveActiveParticipantProhibitionByParticipantId(): Observable<ParticipantProhibitionDataUsersResult>;
    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param roleId (optional) 
     * @return Success
     */
    retrieveAllPermissions(pageIndex: number | undefined, pageSize: number | undefined, roleId: number | null | undefined): Observable<PermissionDataPagedModelUsersResult>;
    /**
     * @return Success
     */
    retrievePrivacyPolicy(): Observable<PrivacyPolicyDataUsersResult>;
    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param trainingProviderId (optional) 
     * @param programTypeId (optional) 
     * @return Success
     */
    retrieveAllAppliablePrograms(pageIndex: number | undefined, pageSize: number | undefined, trainingProviderId: number | undefined, programTypeId: number | undefined): Observable<SelectAllAppliableProgramsDataPagedModelUsersResult>;
    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param trainingProviderId (optional) 
     * @param programTypeId (optional) 
     * @return Success
     */
    retrieveAllActivePrograms(pageIndex: number | undefined, pageSize: number | undefined, trainingProviderId: number | undefined, programTypeId: number | undefined): Observable<SelectAllActiveProgramsDataPagedModelUsersResult>;
    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param trainingProviderId (optional) 
     * @param programTypeId (optional) 
     * @return Success
     */
    retrieveAllOnHoldPrograms(pageIndex: number | undefined, pageSize: number | undefined, trainingProviderId: number | undefined, programTypeId: number | undefined): Observable<SelectAllOnHoldProgramsDataPagedModelUsersResult>;
    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param trainingProviderId (optional) 
     * @param programTypeId (optional) 
     * @return Success
     */
    retrieveAllCompletedPrograms(pageIndex: number | undefined, pageSize: number | undefined, trainingProviderId: number | undefined, programTypeId: number | undefined): Observable<SelectAllCompletedProgramsDataPagedModelUsersResult>;
    /**
     * @param programId (optional) 
     * @return Success
     */
    retrieveOneAppliableProgramById(programId: number | undefined): Observable<SelectOneAppliableProgramDataUsersResult>;
    /**
     * @param active (optional) 
     * @param programTypeId (optional) 
     * @param examDate (optional) 
     * @param year (optional) 
     * @return Success
     */
    fillPrograms(active: boolean | null | undefined, programTypeId: number | null | undefined, examDate: Date | null | undefined, year: number | null | undefined): Observable<FillDataListUsersResult>;
    /**
     * @param body (optional) 
     * @return Success
     */
    insertProgramApplicationAsApplied(body: InsertProgramApplicationRequestData | undefined): Observable<InsertIdResultInfo>;
    /**
     * @param body (optional) 
     * @return Success
     */
    insertProgramApplicationAsOnWaitList(body: InsertProgramApplicationRequestData | undefined): Observable<InsertIdResultInfo>;
    /**
     * @param programId (optional) 
     * @param cancelledDescription (optional) 
     * @param cancelledWithDocuments (optional) 
     * @param fileDescriptions (optional) 
     * @param files (optional) 
     * @return Success
     */
    cancelProgramApplication(programId: number | undefined, cancelledDescription: string | null | undefined, cancelledWithDocuments: boolean | undefined, fileDescriptions: string[] | null | undefined, files: FileParameter[] | null | undefined): Observable<InsertIdResultInfo>;
    /**
     * @param programId (optional) 
     * @return Success
     */
    retrieveOneProgramApplicationById(programId: number | undefined): Observable<SelectOneProgramApplicationDataUsersResult>;
    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param programId (optional) 
     * @return Success
     */
    retrieveAllProgramDaysByProgramId(pageIndex: number | undefined, pageSize: number | undefined, programId: number | undefined): Observable<SelectAllProgramDaysDataPagedModelUsersResult>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateProgramDay(body: ProgramDayData | undefined): Observable<DbResultInfo>;
    /**
     * @param programDayId (optional) 
     * @return Success
     */
    insertProgramDayAttendance(programDayId: number | undefined): Observable<InsertIdResultInfo>;
    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param programTypeId (optional) 
     * @return Success
     */
    retrieveActiveProgramQuestionnaire(pageIndex: number | undefined, pageSize: number | undefined, programTypeId: number | undefined): Observable<ProgramQuestionnaireDataUsersResult>;
    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param programQuestionnaireId (optional) 
     * @param programSurveyId (optional) 
     * @return Success
     */
    retrieveProgramQuestionnaireById(pageIndex: number | undefined, pageSize: number | undefined, programQuestionnaireId: number | undefined, programSurveyId: number | undefined): Observable<ProgramQuestionnaireDataUsersResult>;
    /**
     * @param body (optional) 
     * @return Success
     */
    insertProgramSurvey(body: InsertProgramSurveyRequestData | undefined): Observable<InsertIdResultInfo>;
    /**
     * @return Success
     */
    fillProgramTypes(): Observable<ShortFillDataListUsersResult>;
    /**
     * @return Success
     */
    fillRoles(): Observable<FillDataListUsersResult>;
    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param trainerInvitationId (optional) 
     * @return Success
     */
    retrieveAllTrainerApplicationAttachmentsByTrainerInvitationId(pageIndex: number | undefined, pageSize: number | undefined, trainerInvitationId: number | undefined): Observable<TrainerApplicationAttachmentDataPagedModelUsersResult>;
    /**
     * @param trainerApplicationAttachmentId (optional) 
     * @return Success
     */
    downloadTrainerApplicationAttachmentFile(trainerApplicationAttachmentId: number | undefined): Observable<FileResponse>;
    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    retrieveAllTrainerCertificatesByTrainerId(pageIndex: number | undefined, pageSize: number | undefined): Observable<SelectAllTrainerCertificatesDataPagedModelUsersResult>;
    /**
     * @param body (optional) 
     * @return Success
     */
    insertTrainerCertificate(body: InsertTrainerCertificateRequestData | undefined): Observable<InsertIdResultInfo>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateTrainerCertificate(body: TrainerCertificateData | undefined): Observable<DbResultInfo>;
    /**
     * @param trainerCertificateId (optional) 
     * @return Success
     */
    retrieveOneTrainerCertificateById(trainerCertificateId: number | undefined): Observable<TrainerCertificateDataUsersResult>;
    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    retrieveAllCertifiedTrainersForRegister(pageIndex: number | undefined, pageSize: number | undefined): Observable<SelectAllTrainerCertificatesForRegisterDataPagedModelUsersResult>;
    /**
     * @param body (optional) 
     * @return Success
     */
    insertTrainerCertificateRenewalRequest(body: InsertTrainerCertificateRenewalRequestData | undefined): Observable<InsertIdResultInfo>;
    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param applicationStatusId (optional) 
     * @param programTypeId (optional) 
     * @return Success
     */
    retrieveAllTrainerInvitationsByTrainerId(pageIndex: number | undefined, pageSize: number | undefined, applicationStatusId: number | undefined, programTypeId: number | undefined): Observable<TrainerInvitationDataPagedModelUsersResult>;
    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param active (optional) 
     * @param programTypeId (optional) 
     * @param year (optional) 
     * @return Success
     */
    retrieveAllTrainerInvitationsByTrainerIdForMaterials(pageIndex: number | undefined, pageSize: number | undefined, active: boolean | null | undefined, programTypeId: number | undefined, year: number | null | undefined): Observable<TrainerInvitationForMaterialsDataPagedModelUsersResult>;
    /**
     * @param trainerInvitationId (optional) 
     * @return Success
     */
    acceptTrainerInvitation(trainerInvitationId: number | undefined): Observable<DbResultInfo>;
    /**
     * @param trainerInvitationId (optional) 
     * @param cancelledDescription (optional) 
     * @param cancelledWithDocuments (optional) 
     * @param fileDescriptions (optional) 
     * @param files (optional) 
     * @return Success
     */
    cancelTrainerInvitation(trainerInvitationId: number | undefined, cancelledDescription: string | null | undefined, cancelledWithDocuments: boolean | undefined, fileDescriptions: string[] | null | undefined, files: FileParameter[] | null | undefined): Observable<DbResultInfo>;
    /**
     * @param trainerInvitationId (optional) 
     * @return Success
     */
    retrieveOneTrainerInvitationById(trainerInvitationId: number | undefined): Observable<SelectOneTrainerInvitationDataUsersResult>;
    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    retrieveActiveTrainerQuestionnaire(pageIndex: number | undefined, pageSize: number | undefined): Observable<TrainerQuestionnaireDataUsersResult>;
    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param trainerQuestionnaireId (optional) 
     * @param trainerSurveyId (optional) 
     * @return Success
     */
    retrieveTrainerQuestionnaireById(pageIndex: number | undefined, pageSize: number | undefined, trainerQuestionnaireId: number | undefined, trainerSurveyId: number | undefined): Observable<TrainerQuestionnaireDataUsersResult>;
    /**
     * @param body (optional) 
     * @return Success
     */
    insertTrainerSurvey(body: InsertTrainerSurveyRequestData | undefined): Observable<InsertIdResultInfo>;
    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    retrieveAllTrainerWorkExperienceByTrainerId(pageIndex: number | undefined, pageSize: number | undefined): Observable<TrainerWorkExperienceDataPagedModelUsersResult>;
    /**
     * @param trainerWorkExperienceId (optional) 
     * @return Success
     */
    retrieveOneTrainerWorkExperienceById(trainerWorkExperienceId: number | undefined): Observable<TrainerWorkExperienceDataUsersResult>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateTrainerWorkExperience(body: TrainerWorkExperienceData | undefined): Observable<DbResultInfo>;
    /**
     * @param body (optional) 
     * @return Success
     */
    insertTrainerWorkExperience(body: TrainerWorkExperienceData | undefined): Observable<InsertIdResultInfo>;
    /**
     * @param trainerWorkExperienceId (optional) 
     * @return Success
     */
    deleteTrainerWorkExperience(trainerWorkExperienceId: number | undefined): Observable<DbResultInfo>;
    /**
     * @param searchParam (optional) 
     * @param isBRO (optional) 
     * @return Success
     */
    fillTrainingProviders(searchParam: string | null | undefined, isBRO: boolean | null | undefined): Observable<FillDataListUsersResult>;
    /**
     * @param key (optional) 
     * @param code (optional) 
     * @return Success
     */
    verifyEmail(key: number | undefined, code: string | null | undefined): Observable<void>;
    /**
     * @param body (optional) 
     * @return Success
     */
    login(body: LoginRequestData | undefined): Observable<LoginUserDataSecurityResult>;
    /**
     * @return Success
     */
    signout(): Observable<SecurityResultStatus>;
    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordRequestData | undefined): Observable<SecurityResultStatus>;
    /**
     * @param body (optional) 
     * @return Success
     */
    forgotPassword(body: ForgotPasswordRequestData | undefined): Observable<SecurityResultStatus>;
    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResetPasswordRequestData | undefined): Observable<SecurityResultStatus>;
    /**
     * @param body (optional) 
     * @return Success
     */
    registerParticipant(body: ParticipantRegistrationData | undefined): Observable<InsertIdResultInfo>;
    /**
     * @return Success
     */
    retrieveParticipantProfile(): Observable<ParticipantProfileDataUsersResult>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateParticipantProfile(body: ParticipantProfileData | undefined): Observable<DbResultInfo>;
    /**
     * @return Success
     */
    retrieveTrainerProfile(): Observable<TrainerProfileDataUsersResult>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateTrainerProfile(body: TrainerProfileData | undefined): Observable<DbResultInfo>;
    /**
     * @return Success
     */
    retrieveCommissionProfile(): Observable<CommissionProfileDataUsersResult>;
    /**
     * @param body (optional) 
     * @return Success
     */
    updateCommissionProfile(body: CommissionProfileData | undefined): Observable<DbResultInfo>;
}

@Injectable()
export class Client implements IClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param programId (optional) 
     * @return Success
     */
    retrieveAllApplicationAttachmentsByProgramApplication(pageIndex: number | undefined, pageSize: number | undefined, programId: number | undefined): Observable<SelectAllApplicationAttachmentsDataPagedModelUsersResult> {
        let url_ = this.baseUrl + "/api/ApplicationAttachment/RetrieveAllApplicationAttachmentsByProgramApplication?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (programId === null)
            throw new Error("The parameter 'programId' cannot be null.");
        else if (programId !== undefined)
            url_ += "programId=" + encodeURIComponent("" + programId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveAllApplicationAttachmentsByProgramApplication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveAllApplicationAttachmentsByProgramApplication(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectAllApplicationAttachmentsDataPagedModelUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectAllApplicationAttachmentsDataPagedModelUsersResult>;
        }));
    }

    protected processRetrieveAllApplicationAttachmentsByProgramApplication(response: HttpResponseBase): Observable<SelectAllApplicationAttachmentsDataPagedModelUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SelectAllApplicationAttachmentsDataPagedModelUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectAllApplicationAttachmentsDataPagedModelUsersResult>(null as any);
    }

    /**
     * @param applicationAttachmentId (optional) 
     * @return Success
     */
    downloadApplicationAttachmentFile(applicationAttachmentId: number | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ApplicationAttachment/DownloadApplicationAttachmentFile?";
        if (applicationAttachmentId === null)
            throw new Error("The parameter 'applicationAttachmentId' cannot be null.");
        else if (applicationAttachmentId !== undefined)
            url_ += "applicationAttachmentId=" + encodeURIComponent("" + applicationAttachmentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadApplicationAttachmentFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadApplicationAttachmentFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDownloadApplicationAttachmentFile(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    /**
     * @return Success
     */
    fillCertificateTypes(): Observable<ShortFillDataListUsersResult> {
        let url_ = this.baseUrl + "/api/CertificateType/FillCertificateTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFillCertificateTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFillCertificateTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ShortFillDataListUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ShortFillDataListUsersResult>;
        }));
    }

    protected processFillCertificateTypes(response: HttpResponseBase): Observable<ShortFillDataListUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShortFillDataListUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShortFillDataListUsersResult>(null as any);
    }

    /**
     * @return Success
     */
    fillCities(): Observable<FillCityDataListUsersResult> {
        let url_ = this.baseUrl + "/api/City/FillCities";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFillCities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFillCities(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FillCityDataListUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FillCityDataListUsersResult>;
        }));
    }

    protected processFillCities(response: HttpResponseBase): Observable<FillCityDataListUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FillCityDataListUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FillCityDataListUsersResult>(null as any);
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param commissionInvitationId (optional) 
     * @return Success
     */
    retrieveAllCommissionApplicationAttachmentsByCommissionInvitationId(pageIndex: number | undefined, pageSize: number | undefined, commissionInvitationId: number | undefined): Observable<CommissionApplicationAttachmentDataPagedModelUsersResult> {
        let url_ = this.baseUrl + "/api/CommissionApplicationAttachment/RetrieveAllCommissionApplicationAttachmentsByCommissionInvitationId?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (commissionInvitationId === null)
            throw new Error("The parameter 'commissionInvitationId' cannot be null.");
        else if (commissionInvitationId !== undefined)
            url_ += "commissionInvitationId=" + encodeURIComponent("" + commissionInvitationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveAllCommissionApplicationAttachmentsByCommissionInvitationId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveAllCommissionApplicationAttachmentsByCommissionInvitationId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommissionApplicationAttachmentDataPagedModelUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommissionApplicationAttachmentDataPagedModelUsersResult>;
        }));
    }

    protected processRetrieveAllCommissionApplicationAttachmentsByCommissionInvitationId(response: HttpResponseBase): Observable<CommissionApplicationAttachmentDataPagedModelUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommissionApplicationAttachmentDataPagedModelUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommissionApplicationAttachmentDataPagedModelUsersResult>(null as any);
    }

    /**
     * @param commissionApplicationAttachmentId (optional) 
     * @return Success
     */
    downloadCommissionApplicationAttachmentFile(commissionApplicationAttachmentId: number | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/CommissionApplicationAttachment/DownloadCommissionApplicationAttachmentFile?";
        if (commissionApplicationAttachmentId === null)
            throw new Error("The parameter 'commissionApplicationAttachmentId' cannot be null.");
        else if (commissionApplicationAttachmentId !== undefined)
            url_ += "commissionApplicationAttachmentId=" + encodeURIComponent("" + commissionApplicationAttachmentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadCommissionApplicationAttachmentFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadCommissionApplicationAttachmentFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDownloadCommissionApplicationAttachmentFile(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param applicationStatusId (optional) 
     * @param programTypeId (optional) 
     * @return Success
     */
    retrieveAllCommissionInvitationsByCommissionId(pageIndex: number | undefined, pageSize: number | undefined, applicationStatusId: number | null | undefined, programTypeId: number | null | undefined): Observable<CommissionInvitationDataPagedModelUsersResult> {
        let url_ = this.baseUrl + "/api/CommissionInvitation/RetrieveAllCommissionInvitationsByCommissionId?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (applicationStatusId !== undefined && applicationStatusId !== null)
            url_ += "applicationStatusId=" + encodeURIComponent("" + applicationStatusId) + "&";
        if (programTypeId !== undefined && programTypeId !== null)
            url_ += "programTypeId=" + encodeURIComponent("" + programTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveAllCommissionInvitationsByCommissionId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveAllCommissionInvitationsByCommissionId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommissionInvitationDataPagedModelUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommissionInvitationDataPagedModelUsersResult>;
        }));
    }

    protected processRetrieveAllCommissionInvitationsByCommissionId(response: HttpResponseBase): Observable<CommissionInvitationDataPagedModelUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommissionInvitationDataPagedModelUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommissionInvitationDataPagedModelUsersResult>(null as any);
    }

    /**
     * @param commissionInvitationId (optional) 
     * @return Success
     */
    acceptCommissionInvitation(commissionInvitationId: number | undefined): Observable<DbResultInfo> {
        let url_ = this.baseUrl + "/api/CommissionInvitation/AcceptCommissionInvitation?";
        if (commissionInvitationId === null)
            throw new Error("The parameter 'commissionInvitationId' cannot be null.");
        else if (commissionInvitationId !== undefined)
            url_ += "commissionInvitationId=" + encodeURIComponent("" + commissionInvitationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAcceptCommissionInvitation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAcceptCommissionInvitation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DbResultInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DbResultInfo>;
        }));
    }

    protected processAcceptCommissionInvitation(response: HttpResponseBase): Observable<DbResultInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DbResultInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DbResultInfo>(null as any);
    }

    /**
     * @param commissionInvitationId (optional) 
     * @param cancelledDescription (optional) 
     * @param cancelledWithDocuments (optional) 
     * @param fileDescriptions (optional) 
     * @param files (optional) 
     * @return Success
     */
    cancelCommissionInvitation(commissionInvitationId: number | undefined, cancelledDescription: string | null | undefined, cancelledWithDocuments: boolean | undefined, fileDescriptions: string[] | null | undefined, files: FileParameter[] | null | undefined): Observable<DbResultInfo> {
        let url_ = this.baseUrl + "/api/CommissionInvitation/CancelCommissionInvitation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (commissionInvitationId === null || commissionInvitationId === undefined)
            throw new Error("The parameter 'commissionInvitationId' cannot be null.");
        else
            content_.append("CommissionInvitationId", commissionInvitationId.toString());
        if (cancelledDescription !== null && cancelledDescription !== undefined)
            content_.append("CancelledDescription", cancelledDescription.toString());
        if (cancelledWithDocuments === null || cancelledWithDocuments === undefined)
            throw new Error("The parameter 'cancelledWithDocuments' cannot be null.");
        else
            content_.append("CancelledWithDocuments", cancelledWithDocuments.toString());
        if (fileDescriptions !== null && fileDescriptions !== undefined)
            fileDescriptions.forEach(item_ => content_.append("fileDescriptions", item_.toString()));
        if (files !== null && files !== undefined)
            files.forEach(item_ => content_.append("files", item_.data, item_.fileName ? item_.fileName : "files") );

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelCommissionInvitation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelCommissionInvitation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DbResultInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DbResultInfo>;
        }));
    }

    protected processCancelCommissionInvitation(response: HttpResponseBase): Observable<DbResultInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DbResultInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DbResultInfo>(null as any);
    }

    /**
     * @param commissionInvitationId (optional) 
     * @return Success
     */
    retrieveOneCommissionInvitationById(commissionInvitationId: number | undefined): Observable<SelectOneCommissionInvitationDataUsersResult> {
        let url_ = this.baseUrl + "/api/CommissionInvitation/RetrieveOneCommissionInvitationById?";
        if (commissionInvitationId === null)
            throw new Error("The parameter 'commissionInvitationId' cannot be null.");
        else if (commissionInvitationId !== undefined)
            url_ += "commissionInvitationId=" + encodeURIComponent("" + commissionInvitationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveOneCommissionInvitationById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveOneCommissionInvitationById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectOneCommissionInvitationDataUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectOneCommissionInvitationDataUsersResult>;
        }));
    }

    protected processRetrieveOneCommissionInvitationById(response: HttpResponseBase): Observable<SelectOneCommissionInvitationDataUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SelectOneCommissionInvitationDataUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectOneCommissionInvitationDataUsersResult>(null as any);
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param programId (optional) 
     * @param programTypeId (optional) 
     * @param year (optional) 
     * @return Success
     */
    retrieveAllExamsByCommissionId(pageIndex: number | undefined, pageSize: number | undefined, programId: number | undefined, programTypeId: number | null | undefined, year: number | null | undefined): Observable<SelectAllExamsDataPagedModelUsersResult> {
        let url_ = this.baseUrl + "/api/Exam/RetrieveAllExamsByCommissionId?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (programId === null)
            throw new Error("The parameter 'programId' cannot be null.");
        else if (programId !== undefined)
            url_ += "programId=" + encodeURIComponent("" + programId) + "&";
        if (programTypeId !== undefined && programTypeId !== null)
            url_ += "programTypeId=" + encodeURIComponent("" + programTypeId) + "&";
        if (year !== undefined && year !== null)
            url_ += "year=" + encodeURIComponent("" + year) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveAllExamsByCommissionId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveAllExamsByCommissionId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectAllExamsDataPagedModelUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectAllExamsDataPagedModelUsersResult>;
        }));
    }

    protected processRetrieveAllExamsByCommissionId(response: HttpResponseBase): Observable<SelectAllExamsDataPagedModelUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SelectAllExamsDataPagedModelUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectAllExamsDataPagedModelUsersResult>(null as any);
    }

    /**
     * @param examId (optional) 
     * @return Success
     */
    retrieveOneExamById(examId: number | undefined): Observable<ExamDataUsersResult> {
        let url_ = this.baseUrl + "/api/Exam/RetrieveOneExamById?";
        if (examId === null)
            throw new Error("The parameter 'examId' cannot be null.");
        else if (examId !== undefined)
            url_ += "examId=" + encodeURIComponent("" + examId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveOneExamById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveOneExamById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExamDataUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExamDataUsersResult>;
        }));
    }

    protected processRetrieveOneExamById(response: HttpResponseBase): Observable<ExamDataUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExamDataUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExamDataUsersResult>(null as any);
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param programId (optional) 
     * @return Success
     */
    retrieveAllExamsByParticipantId(pageIndex: number | undefined, pageSize: number | undefined, programId: number | null | undefined): Observable<SelectAllExamsForParticipantDataPagedModelUsersResult> {
        let url_ = this.baseUrl + "/api/Exam/RetrieveAllExamsByParticipantId?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (programId !== undefined && programId !== null)
            url_ += "programId=" + encodeURIComponent("" + programId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveAllExamsByParticipantId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveAllExamsByParticipantId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectAllExamsForParticipantDataPagedModelUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectAllExamsForParticipantDataPagedModelUsersResult>;
        }));
    }

    protected processRetrieveAllExamsByParticipantId(response: HttpResponseBase): Observable<SelectAllExamsForParticipantDataPagedModelUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SelectAllExamsForParticipantDataPagedModelUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectAllExamsForParticipantDataPagedModelUsersResult>(null as any);
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param examId (optional) 
     * @return Success
     */
    retrieveAllExamResultsByExamId(pageIndex: number | undefined, pageSize: number | undefined, examId: number | undefined): Observable<SelectAllExamResultsDataPagedModelUsersResult> {
        let url_ = this.baseUrl + "/api/ExamResult/RetrieveAllExamResultsByExamId?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (examId === null)
            throw new Error("The parameter 'examId' cannot be null.");
        else if (examId !== undefined)
            url_ += "examId=" + encodeURIComponent("" + examId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveAllExamResultsByExamId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveAllExamResultsByExamId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectAllExamResultsDataPagedModelUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectAllExamResultsDataPagedModelUsersResult>;
        }));
    }

    protected processRetrieveAllExamResultsByExamId(response: HttpResponseBase): Observable<SelectAllExamResultsDataPagedModelUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SelectAllExamResultsDataPagedModelUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectAllExamResultsDataPagedModelUsersResult>(null as any);
    }

    /**
     * @param examId (optional) 
     * @return Success
     */
    generateExamResultsReport(examId: number | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ExamResult/GenerateExamResultsReport?";
        if (examId === null)
            throw new Error("The parameter 'examId' cannot be null.");
        else if (examId !== undefined)
            url_ += "examId=" + encodeURIComponent("" + examId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateExamResultsReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateExamResultsReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGenerateExamResultsReport(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    /**
     * @return Success
     */
    fillExamTypes(): Observable<ShortFillDataListUsersResult> {
        let url_ = this.baseUrl + "/api/ExamType/FillExamTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFillExamTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFillExamTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ShortFillDataListUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ShortFillDataListUsersResult>;
        }));
    }

    protected processFillExamTypes(response: HttpResponseBase): Observable<ShortFillDataListUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShortFillDataListUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShortFillDataListUsersResult>(null as any);
    }

    /**
     * @param searchParam (optional) 
     * @return Success
     */
    fillInstitutions(searchParam: string | null | undefined): Observable<FillDataListUsersResult> {
        let url_ = this.baseUrl + "/api/Institution/FillInstitutions?";
        if (searchParam !== undefined && searchParam !== null)
            url_ += "searchParam=" + encodeURIComponent("" + searchParam) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFillInstitutions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFillInstitutions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FillDataListUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FillDataListUsersResult>;
        }));
    }

    protected processFillInstitutions(response: HttpResponseBase): Observable<FillDataListUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FillDataListUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FillDataListUsersResult>(null as any);
    }

    /**
     * @return Success
     */
    fillLanguages(): Observable<ShortFillDataListUsersResult> {
        let url_ = this.baseUrl + "/api/Language/FillLanguages";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFillLanguages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFillLanguages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ShortFillDataListUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ShortFillDataListUsersResult>;
        }));
    }

    protected processFillLanguages(response: HttpResponseBase): Observable<ShortFillDataListUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShortFillDataListUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShortFillDataListUsersResult>(null as any);
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param trainerInvitationId (optional) 
     * @return Success
     */
    retrieveAllMaterialsByTrainerInvitationId(pageIndex: number | undefined, pageSize: number | undefined, trainerInvitationId: number | undefined): Observable<MaterialDataPagedModelUsersResult> {
        let url_ = this.baseUrl + "/api/Material/RetrieveAllMaterialsByTrainerInvitationId?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (trainerInvitationId === null)
            throw new Error("The parameter 'trainerInvitationId' cannot be null.");
        else if (trainerInvitationId !== undefined)
            url_ += "trainerInvitationId=" + encodeURIComponent("" + trainerInvitationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveAllMaterialsByTrainerInvitationId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveAllMaterialsByTrainerInvitationId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MaterialDataPagedModelUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MaterialDataPagedModelUsersResult>;
        }));
    }

    protected processRetrieveAllMaterialsByTrainerInvitationId(response: HttpResponseBase): Observable<MaterialDataPagedModelUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MaterialDataPagedModelUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MaterialDataPagedModelUsersResult>(null as any);
    }

    /**
     * @param trainerInvitationId (optional) 
     * @param name (optional) 
     * @param file (optional) 
     * @return Success
     */
    insertMaterial(trainerInvitationId: number | undefined, name: string | null | undefined, file: FileParameter | null | undefined): Observable<InsertIdResultInfo> {
        let url_ = this.baseUrl + "/api/Material/InsertMaterial";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (trainerInvitationId === null || trainerInvitationId === undefined)
            throw new Error("The parameter 'trainerInvitationId' cannot be null.");
        else
            content_.append("TrainerInvitationId", trainerInvitationId.toString());
        if (name !== null && name !== undefined)
            content_.append("Name", name.toString());
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertMaterial(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertMaterial(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertIdResultInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertIdResultInfo>;
        }));
    }

    protected processInsertMaterial(response: HttpResponseBase): Observable<InsertIdResultInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertIdResultInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertIdResultInfo>(null as any);
    }

    /**
     * @param materialId (optional) 
     * @return Success
     */
    deleteMaterial(materialId: number | undefined): Observable<DbResultInfo> {
        let url_ = this.baseUrl + "/api/Material/DeleteMaterial?";
        if (materialId === null)
            throw new Error("The parameter 'materialId' cannot be null.");
        else if (materialId !== undefined)
            url_ += "materialId=" + encodeURIComponent("" + materialId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMaterial(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMaterial(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DbResultInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DbResultInfo>;
        }));
    }

    protected processDeleteMaterial(response: HttpResponseBase): Observable<DbResultInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DbResultInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DbResultInfo>(null as any);
    }

    /**
     * @param materialId (optional) 
     * @return Success
     */
    downloadMaterialFile(materialId: number | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Material/DownloadMaterialFile?";
        if (materialId === null)
            throw new Error("The parameter 'materialId' cannot be null.");
        else if (materialId !== undefined)
            url_ += "materialId=" + encodeURIComponent("" + materialId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadMaterialFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadMaterialFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDownloadMaterialFile(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param active (optional) 
     * @param programTypeId (optional) 
     * @return Success
     */
    retrieveAllMaterialsByParticipantId(pageIndex: number | undefined, pageSize: number | undefined, active: boolean | null | undefined, programTypeId: number | null | undefined): Observable<SelectAllMaterialsDataPagedModelUsersResult> {
        let url_ = this.baseUrl + "/api/Material/RetrieveAllMaterialsByParticipantId?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (active !== undefined && active !== null)
            url_ += "active=" + encodeURIComponent("" + active) + "&";
        if (programTypeId !== undefined && programTypeId !== null)
            url_ += "programTypeId=" + encodeURIComponent("" + programTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveAllMaterialsByParticipantId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveAllMaterialsByParticipantId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectAllMaterialsDataPagedModelUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectAllMaterialsDataPagedModelUsersResult>;
        }));
    }

    protected processRetrieveAllMaterialsByParticipantId(response: HttpResponseBase): Observable<SelectAllMaterialsDataPagedModelUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SelectAllMaterialsDataPagedModelUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectAllMaterialsDataPagedModelUsersResult>(null as any);
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    retrieveAllMessageUsersByUserId(pageIndex: number | undefined, pageSize: number | undefined): Observable<SelectAllMessageUsersDataPagedModelUsersResult> {
        let url_ = this.baseUrl + "/api/MessageUser/RetrieveAllMessageUsersByUserId?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveAllMessageUsersByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveAllMessageUsersByUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectAllMessageUsersDataPagedModelUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectAllMessageUsersDataPagedModelUsersResult>;
        }));
    }

    protected processRetrieveAllMessageUsersByUserId(response: HttpResponseBase): Observable<SelectAllMessageUsersDataPagedModelUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SelectAllMessageUsersDataPagedModelUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectAllMessageUsersDataPagedModelUsersResult>(null as any);
    }

    /**
     * @return Success
     */
    retrieveAllMessageUsersTotalItems(): Observable<NotificationTotalItemsMessageUserUsersResult> {
        let url_ = this.baseUrl + "/api/MessageUser/RetrieveAllMessageUsersTotalItems";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveAllMessageUsersTotalItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveAllMessageUsersTotalItems(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NotificationTotalItemsMessageUserUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NotificationTotalItemsMessageUserUsersResult>;
        }));
    }

    protected processRetrieveAllMessageUsersTotalItems(response: HttpResponseBase): Observable<NotificationTotalItemsMessageUserUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationTotalItemsMessageUserUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NotificationTotalItemsMessageUserUsersResult>(null as any);
    }

    /**
     * @param searchParam (optional) 
     * @return Success
     */
    fillParticipants(searchParam: string | null | undefined): Observable<FillDataListUsersResult> {
        let url_ = this.baseUrl + "/api/Participant/FillParticipants?";
        if (searchParam !== undefined && searchParam !== null)
            url_ += "searchParam=" + encodeURIComponent("" + searchParam) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFillParticipants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFillParticipants(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FillDataListUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FillDataListUsersResult>;
        }));
    }

    protected processFillParticipants(response: HttpResponseBase): Observable<FillDataListUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FillDataListUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FillDataListUsersResult>(null as any);
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    retrieveAllParticipantCertificatesByParticipantId(pageIndex: number | undefined, pageSize: number | undefined): Observable<SelectAllParticipantCertificatesDataPagedModelUsersResult> {
        let url_ = this.baseUrl + "/api/ParticipantCertificate/RetrieveAllParticipantCertificatesByParticipantId?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveAllParticipantCertificatesByParticipantId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveAllParticipantCertificatesByParticipantId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectAllParticipantCertificatesDataPagedModelUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectAllParticipantCertificatesDataPagedModelUsersResult>;
        }));
    }

    protected processRetrieveAllParticipantCertificatesByParticipantId(response: HttpResponseBase): Observable<SelectAllParticipantCertificatesDataPagedModelUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SelectAllParticipantCertificatesDataPagedModelUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectAllParticipantCertificatesDataPagedModelUsersResult>(null as any);
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param institutionName (optional) 
     * @param participantId (optional) 
     * @param issueYear (optional) 
     * @return Success
     */
    retrieveAllCertifiedParticipantsForRegister(pageIndex: number | undefined, pageSize: number | undefined, institutionName: string | null | undefined, participantId: number | null | undefined, issueYear: number | null | undefined): Observable<SelectAllParticipantCertificatesForRegisterDataPagedModelUsersResult> {
        let url_ = this.baseUrl + "/api/ParticipantCertificate/RetrieveAllCertifiedParticipantsForRegister?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (institutionName !== undefined && institutionName !== null)
            url_ += "institutionName=" + encodeURIComponent("" + institutionName) + "&";
        if (participantId !== undefined && participantId !== null)
            url_ += "participantId=" + encodeURIComponent("" + participantId) + "&";
        if (issueYear !== undefined && issueYear !== null)
            url_ += "issueYear=" + encodeURIComponent("" + issueYear) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveAllCertifiedParticipantsForRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveAllCertifiedParticipantsForRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectAllParticipantCertificatesForRegisterDataPagedModelUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectAllParticipantCertificatesForRegisterDataPagedModelUsersResult>;
        }));
    }

    protected processRetrieveAllCertifiedParticipantsForRegister(response: HttpResponseBase): Observable<SelectAllParticipantCertificatesForRegisterDataPagedModelUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SelectAllParticipantCertificatesForRegisterDataPagedModelUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectAllParticipantCertificatesForRegisterDataPagedModelUsersResult>(null as any);
    }

    /**
     * @param examId (optional) 
     * @param cancelledDescription (optional) 
     * @param cancelledWithDocuments (optional) 
     * @param fileDescriptions (optional) 
     * @param files (optional) 
     * @return Success
     */
    cancelParticipantExam(examId: number | undefined, cancelledDescription: string | null | undefined, cancelledWithDocuments: boolean | undefined, fileDescriptions: string[] | null | undefined, files: FileParameter[] | null | undefined): Observable<InsertIdResultInfo> {
        let url_ = this.baseUrl + "/api/ParticipantExam/CancelParticipantExam";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (examId === null || examId === undefined)
            throw new Error("The parameter 'examId' cannot be null.");
        else
            content_.append("ExamId", examId.toString());
        if (cancelledDescription !== null && cancelledDescription !== undefined)
            content_.append("CancelledDescription", cancelledDescription.toString());
        if (cancelledWithDocuments === null || cancelledWithDocuments === undefined)
            throw new Error("The parameter 'cancelledWithDocuments' cannot be null.");
        else
            content_.append("CancelledWithDocuments", cancelledWithDocuments.toString());
        if (fileDescriptions !== null && fileDescriptions !== undefined)
            fileDescriptions.forEach(item_ => content_.append("fileDescriptions", item_.toString()));
        if (files !== null && files !== undefined)
            files.forEach(item_ => content_.append("files", item_.data, item_.fileName ? item_.fileName : "files") );

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelParticipantExam(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelParticipantExam(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertIdResultInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertIdResultInfo>;
        }));
    }

    protected processCancelParticipantExam(response: HttpResponseBase): Observable<InsertIdResultInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertIdResultInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertIdResultInfo>(null as any);
    }

    /**
     * @param participantExamId (optional) 
     * @return Success
     */
    retrieveOneParticipantExamById(participantExamId: number | undefined): Observable<ParticipantExamDataUsersResult> {
        let url_ = this.baseUrl + "/api/ParticipantExam/RetrieveOneParticipantExamById?";
        if (participantExamId === null)
            throw new Error("The parameter 'participantExamId' cannot be null.");
        else if (participantExamId !== undefined)
            url_ += "participantExamId=" + encodeURIComponent("" + participantExamId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveOneParticipantExamById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveOneParticipantExamById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ParticipantExamDataUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ParticipantExamDataUsersResult>;
        }));
    }

    protected processRetrieveOneParticipantExamById(response: HttpResponseBase): Observable<ParticipantExamDataUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ParticipantExamDataUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ParticipantExamDataUsersResult>(null as any);
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param participantExamId (optional) 
     * @return Success
     */
    retrieveAllParticipantExamAttachmentsByParticipantExamId(pageIndex: number | undefined, pageSize: number | undefined, participantExamId: number | undefined): Observable<ParticipantExamAttachmentDataPagedModelUsersResult> {
        let url_ = this.baseUrl + "/api/ParticipantExamAttachment/RetrieveAllParticipantExamAttachmentsByParticipantExamId?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (participantExamId === null)
            throw new Error("The parameter 'participantExamId' cannot be null.");
        else if (participantExamId !== undefined)
            url_ += "participantExamId=" + encodeURIComponent("" + participantExamId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveAllParticipantExamAttachmentsByParticipantExamId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveAllParticipantExamAttachmentsByParticipantExamId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ParticipantExamAttachmentDataPagedModelUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ParticipantExamAttachmentDataPagedModelUsersResult>;
        }));
    }

    protected processRetrieveAllParticipantExamAttachmentsByParticipantExamId(response: HttpResponseBase): Observable<ParticipantExamAttachmentDataPagedModelUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ParticipantExamAttachmentDataPagedModelUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ParticipantExamAttachmentDataPagedModelUsersResult>(null as any);
    }

    /**
     * @param participantExamAttachmentId (optional) 
     * @return Success
     */
    downloadParticipantExamAttachmentFile(participantExamAttachmentId: number | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ParticipantExamAttachment/DownloadParticipantExamAttachmentFile?";
        if (participantExamAttachmentId === null)
            throw new Error("The parameter 'participantExamAttachmentId' cannot be null.");
        else if (participantExamAttachmentId !== undefined)
            url_ += "participantExamAttachmentId=" + encodeURIComponent("" + participantExamAttachmentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadParticipantExamAttachmentFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadParticipantExamAttachmentFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDownloadParticipantExamAttachmentFile(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    /**
     * @return Success
     */
    retrieveActiveParticipantProhibitionByParticipantId(): Observable<ParticipantProhibitionDataUsersResult> {
        let url_ = this.baseUrl + "/api/ParticipantProhibition/RetrieveActiveParticipantProhibitionByParticipantId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveActiveParticipantProhibitionByParticipantId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveActiveParticipantProhibitionByParticipantId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ParticipantProhibitionDataUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ParticipantProhibitionDataUsersResult>;
        }));
    }

    protected processRetrieveActiveParticipantProhibitionByParticipantId(response: HttpResponseBase): Observable<ParticipantProhibitionDataUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ParticipantProhibitionDataUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ParticipantProhibitionDataUsersResult>(null as any);
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param roleId (optional) 
     * @return Success
     */
    retrieveAllPermissions(pageIndex: number | undefined, pageSize: number | undefined, roleId: number | null | undefined): Observable<PermissionDataPagedModelUsersResult> {
        let url_ = this.baseUrl + "/api/Permission/RetrieveAllPermissions?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (roleId !== undefined && roleId !== null)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveAllPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionDataPagedModelUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionDataPagedModelUsersResult>;
        }));
    }

    protected processRetrieveAllPermissions(response: HttpResponseBase): Observable<PermissionDataPagedModelUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDataPagedModelUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PermissionDataPagedModelUsersResult>(null as any);
    }

    /**
     * @return Success
     */
    retrievePrivacyPolicy(): Observable<PrivacyPolicyDataUsersResult> {
        let url_ = this.baseUrl + "/api/PrivacyPolicy/RetrievePrivacyPolicy";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrievePrivacyPolicy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrievePrivacyPolicy(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PrivacyPolicyDataUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PrivacyPolicyDataUsersResult>;
        }));
    }

    protected processRetrievePrivacyPolicy(response: HttpResponseBase): Observable<PrivacyPolicyDataUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrivacyPolicyDataUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrivacyPolicyDataUsersResult>(null as any);
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param trainingProviderId (optional) 
     * @param programTypeId (optional) 
     * @return Success
     */
    retrieveAllAppliablePrograms(pageIndex: number | undefined, pageSize: number | undefined, trainingProviderId: number | undefined, programTypeId: number | undefined): Observable<SelectAllAppliableProgramsDataPagedModelUsersResult> {
        let url_ = this.baseUrl + "/api/Program/RetrieveAllAppliablePrograms?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (trainingProviderId === null)
            throw new Error("The parameter 'trainingProviderId' cannot be null.");
        else if (trainingProviderId !== undefined)
            url_ += "trainingProviderId=" + encodeURIComponent("" + trainingProviderId) + "&";
        if (programTypeId === null)
            throw new Error("The parameter 'programTypeId' cannot be null.");
        else if (programTypeId !== undefined)
            url_ += "programTypeId=" + encodeURIComponent("" + programTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveAllAppliablePrograms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveAllAppliablePrograms(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectAllAppliableProgramsDataPagedModelUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectAllAppliableProgramsDataPagedModelUsersResult>;
        }));
    }

    protected processRetrieveAllAppliablePrograms(response: HttpResponseBase): Observable<SelectAllAppliableProgramsDataPagedModelUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SelectAllAppliableProgramsDataPagedModelUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectAllAppliableProgramsDataPagedModelUsersResult>(null as any);
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param trainingProviderId (optional) 
     * @param programTypeId (optional) 
     * @return Success
     */
    retrieveAllActivePrograms(pageIndex: number | undefined, pageSize: number | undefined, trainingProviderId: number | undefined, programTypeId: number | undefined): Observable<SelectAllActiveProgramsDataPagedModelUsersResult> {
        let url_ = this.baseUrl + "/api/Program/RetrieveAllActivePrograms?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (trainingProviderId === null)
            throw new Error("The parameter 'trainingProviderId' cannot be null.");
        else if (trainingProviderId !== undefined)
            url_ += "trainingProviderId=" + encodeURIComponent("" + trainingProviderId) + "&";
        if (programTypeId === null)
            throw new Error("The parameter 'programTypeId' cannot be null.");
        else if (programTypeId !== undefined)
            url_ += "programTypeId=" + encodeURIComponent("" + programTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveAllActivePrograms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveAllActivePrograms(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectAllActiveProgramsDataPagedModelUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectAllActiveProgramsDataPagedModelUsersResult>;
        }));
    }

    protected processRetrieveAllActivePrograms(response: HttpResponseBase): Observable<SelectAllActiveProgramsDataPagedModelUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SelectAllActiveProgramsDataPagedModelUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectAllActiveProgramsDataPagedModelUsersResult>(null as any);
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param trainingProviderId (optional) 
     * @param programTypeId (optional) 
     * @return Success
     */
    retrieveAllOnHoldPrograms(pageIndex: number | undefined, pageSize: number | undefined, trainingProviderId: number | undefined, programTypeId: number | undefined): Observable<SelectAllOnHoldProgramsDataPagedModelUsersResult> {
        let url_ = this.baseUrl + "/api/Program/RetrieveAllOnHoldPrograms?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (trainingProviderId === null)
            throw new Error("The parameter 'trainingProviderId' cannot be null.");
        else if (trainingProviderId !== undefined)
            url_ += "trainingProviderId=" + encodeURIComponent("" + trainingProviderId) + "&";
        if (programTypeId === null)
            throw new Error("The parameter 'programTypeId' cannot be null.");
        else if (programTypeId !== undefined)
            url_ += "programTypeId=" + encodeURIComponent("" + programTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveAllOnHoldPrograms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveAllOnHoldPrograms(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectAllOnHoldProgramsDataPagedModelUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectAllOnHoldProgramsDataPagedModelUsersResult>;
        }));
    }

    protected processRetrieveAllOnHoldPrograms(response: HttpResponseBase): Observable<SelectAllOnHoldProgramsDataPagedModelUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SelectAllOnHoldProgramsDataPagedModelUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectAllOnHoldProgramsDataPagedModelUsersResult>(null as any);
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param trainingProviderId (optional) 
     * @param programTypeId (optional) 
     * @return Success
     */
    retrieveAllCompletedPrograms(pageIndex: number | undefined, pageSize: number | undefined, trainingProviderId: number | undefined, programTypeId: number | undefined): Observable<SelectAllCompletedProgramsDataPagedModelUsersResult> {
        let url_ = this.baseUrl + "/api/Program/RetrieveAllCompletedPrograms?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (trainingProviderId === null)
            throw new Error("The parameter 'trainingProviderId' cannot be null.");
        else if (trainingProviderId !== undefined)
            url_ += "trainingProviderId=" + encodeURIComponent("" + trainingProviderId) + "&";
        if (programTypeId === null)
            throw new Error("The parameter 'programTypeId' cannot be null.");
        else if (programTypeId !== undefined)
            url_ += "programTypeId=" + encodeURIComponent("" + programTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveAllCompletedPrograms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveAllCompletedPrograms(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectAllCompletedProgramsDataPagedModelUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectAllCompletedProgramsDataPagedModelUsersResult>;
        }));
    }

    protected processRetrieveAllCompletedPrograms(response: HttpResponseBase): Observable<SelectAllCompletedProgramsDataPagedModelUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SelectAllCompletedProgramsDataPagedModelUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectAllCompletedProgramsDataPagedModelUsersResult>(null as any);
    }

    /**
     * @param programId (optional) 
     * @return Success
     */
    retrieveOneAppliableProgramById(programId: number | undefined): Observable<SelectOneAppliableProgramDataUsersResult> {
        let url_ = this.baseUrl + "/api/Program/RetrieveOneAppliableProgramById?";
        if (programId === null)
            throw new Error("The parameter 'programId' cannot be null.");
        else if (programId !== undefined)
            url_ += "programId=" + encodeURIComponent("" + programId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveOneAppliableProgramById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveOneAppliableProgramById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectOneAppliableProgramDataUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectOneAppliableProgramDataUsersResult>;
        }));
    }

    protected processRetrieveOneAppliableProgramById(response: HttpResponseBase): Observable<SelectOneAppliableProgramDataUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SelectOneAppliableProgramDataUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectOneAppliableProgramDataUsersResult>(null as any);
    }

    /**
     * @param active (optional) 
     * @param programTypeId (optional) 
     * @param examDate (optional) 
     * @param year (optional) 
     * @return Success
     */
    fillPrograms(active: boolean | null | undefined, programTypeId: number | null | undefined, examDate: Date | null | undefined, year: number | null | undefined): Observable<FillDataListUsersResult> {
        let url_ = this.baseUrl + "/api/Program/FillPrograms?";
        if (active !== undefined && active !== null)
            url_ += "active=" + encodeURIComponent("" + active) + "&";
        if (programTypeId !== undefined && programTypeId !== null)
            url_ += "programTypeId=" + encodeURIComponent("" + programTypeId) + "&";
        if (examDate !== undefined && examDate !== null)
            url_ += "examDate=" + encodeURIComponent(examDate ? "" + examDate.toISOString() : "") + "&";
        if (year !== undefined && year !== null)
            url_ += "year=" + encodeURIComponent("" + year) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFillPrograms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFillPrograms(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FillDataListUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FillDataListUsersResult>;
        }));
    }

    protected processFillPrograms(response: HttpResponseBase): Observable<FillDataListUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FillDataListUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FillDataListUsersResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insertProgramApplicationAsApplied(body: InsertProgramApplicationRequestData | undefined): Observable<InsertIdResultInfo> {
        let url_ = this.baseUrl + "/api/ProgramApplication/InsertProgramApplicationAsApplied";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertProgramApplicationAsApplied(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertProgramApplicationAsApplied(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertIdResultInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertIdResultInfo>;
        }));
    }

    protected processInsertProgramApplicationAsApplied(response: HttpResponseBase): Observable<InsertIdResultInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertIdResultInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertIdResultInfo>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insertProgramApplicationAsOnWaitList(body: InsertProgramApplicationRequestData | undefined): Observable<InsertIdResultInfo> {
        let url_ = this.baseUrl + "/api/ProgramApplication/InsertProgramApplicationAsOnWaitList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertProgramApplicationAsOnWaitList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertProgramApplicationAsOnWaitList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertIdResultInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertIdResultInfo>;
        }));
    }

    protected processInsertProgramApplicationAsOnWaitList(response: HttpResponseBase): Observable<InsertIdResultInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertIdResultInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertIdResultInfo>(null as any);
    }

    /**
     * @param programId (optional) 
     * @param cancelledDescription (optional) 
     * @param cancelledWithDocuments (optional) 
     * @param fileDescriptions (optional) 
     * @param files (optional) 
     * @return Success
     */
    cancelProgramApplication(programId: number | undefined, cancelledDescription: string | null | undefined, cancelledWithDocuments: boolean | undefined, fileDescriptions: string[] | null | undefined, files: FileParameter[] | null | undefined): Observable<InsertIdResultInfo> {
        let url_ = this.baseUrl + "/api/ProgramApplication/CancelProgramApplication";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (programId === null || programId === undefined)
            throw new Error("The parameter 'programId' cannot be null.");
        else
            content_.append("ProgramId", programId.toString());
        if (cancelledDescription !== null && cancelledDescription !== undefined)
            content_.append("CancelledDescription", cancelledDescription.toString());
        if (cancelledWithDocuments === null || cancelledWithDocuments === undefined)
            throw new Error("The parameter 'cancelledWithDocuments' cannot be null.");
        else
            content_.append("CancelledWithDocuments", cancelledWithDocuments.toString());
        if (fileDescriptions !== null && fileDescriptions !== undefined)
            fileDescriptions.forEach(item_ => content_.append("fileDescriptions", item_.toString()));
        if (files !== null && files !== undefined)
            files.forEach(item_ => content_.append("files", item_.data, item_.fileName ? item_.fileName : "files") );

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelProgramApplication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelProgramApplication(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertIdResultInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertIdResultInfo>;
        }));
    }

    protected processCancelProgramApplication(response: HttpResponseBase): Observable<InsertIdResultInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertIdResultInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertIdResultInfo>(null as any);
    }

    /**
     * @param programId (optional) 
     * @return Success
     */
    retrieveOneProgramApplicationById(programId: number | undefined): Observable<SelectOneProgramApplicationDataUsersResult> {
        let url_ = this.baseUrl + "/api/ProgramApplication/RetrieveOneProgramApplicationById?";
        if (programId === null)
            throw new Error("The parameter 'programId' cannot be null.");
        else if (programId !== undefined)
            url_ += "programId=" + encodeURIComponent("" + programId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveOneProgramApplicationById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveOneProgramApplicationById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectOneProgramApplicationDataUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectOneProgramApplicationDataUsersResult>;
        }));
    }

    protected processRetrieveOneProgramApplicationById(response: HttpResponseBase): Observable<SelectOneProgramApplicationDataUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SelectOneProgramApplicationDataUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectOneProgramApplicationDataUsersResult>(null as any);
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param programId (optional) 
     * @return Success
     */
    retrieveAllProgramDaysByProgramId(pageIndex: number | undefined, pageSize: number | undefined, programId: number | undefined): Observable<SelectAllProgramDaysDataPagedModelUsersResult> {
        let url_ = this.baseUrl + "/api/ProgramDay/RetrieveAllProgramDaysByProgramId?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (programId === null)
            throw new Error("The parameter 'programId' cannot be null.");
        else if (programId !== undefined)
            url_ += "programId=" + encodeURIComponent("" + programId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveAllProgramDaysByProgramId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveAllProgramDaysByProgramId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectAllProgramDaysDataPagedModelUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectAllProgramDaysDataPagedModelUsersResult>;
        }));
    }

    protected processRetrieveAllProgramDaysByProgramId(response: HttpResponseBase): Observable<SelectAllProgramDaysDataPagedModelUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SelectAllProgramDaysDataPagedModelUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectAllProgramDaysDataPagedModelUsersResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProgramDay(body: ProgramDayData | undefined): Observable<DbResultInfo> {
        let url_ = this.baseUrl + "/api/ProgramDay/UpdateProgramDay";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProgramDay(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProgramDay(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DbResultInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DbResultInfo>;
        }));
    }

    protected processUpdateProgramDay(response: HttpResponseBase): Observable<DbResultInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DbResultInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DbResultInfo>(null as any);
    }

    /**
     * @param programDayId (optional) 
     * @return Success
     */
    insertProgramDayAttendance(programDayId: number | undefined): Observable<InsertIdResultInfo> {
        let url_ = this.baseUrl + "/api/ProgramDayAttendance/InsertProgramDayAttendance?";
        if (programDayId === null)
            throw new Error("The parameter 'programDayId' cannot be null.");
        else if (programDayId !== undefined)
            url_ += "programDayId=" + encodeURIComponent("" + programDayId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertProgramDayAttendance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertProgramDayAttendance(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertIdResultInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertIdResultInfo>;
        }));
    }

    protected processInsertProgramDayAttendance(response: HttpResponseBase): Observable<InsertIdResultInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertIdResultInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertIdResultInfo>(null as any);
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param programTypeId (optional) 
     * @return Success
     */
    retrieveActiveProgramQuestionnaire(pageIndex: number | undefined, pageSize: number | undefined, programTypeId: number | undefined): Observable<ProgramQuestionnaireDataUsersResult> {
        let url_ = this.baseUrl + "/api/ProgramQuestionnaire/RetrieveActiveProgramQuestionnaire?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (programTypeId === null)
            throw new Error("The parameter 'programTypeId' cannot be null.");
        else if (programTypeId !== undefined)
            url_ += "programTypeId=" + encodeURIComponent("" + programTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveActiveProgramQuestionnaire(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveActiveProgramQuestionnaire(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProgramQuestionnaireDataUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProgramQuestionnaireDataUsersResult>;
        }));
    }

    protected processRetrieveActiveProgramQuestionnaire(response: HttpResponseBase): Observable<ProgramQuestionnaireDataUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProgramQuestionnaireDataUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProgramQuestionnaireDataUsersResult>(null as any);
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param programQuestionnaireId (optional) 
     * @param programSurveyId (optional) 
     * @return Success
     */
    retrieveProgramQuestionnaireById(pageIndex: number | undefined, pageSize: number | undefined, programQuestionnaireId: number | undefined, programSurveyId: number | undefined): Observable<ProgramQuestionnaireDataUsersResult> {
        let url_ = this.baseUrl + "/api/ProgramQuestionnaire/RetrieveProgramQuestionnaireById?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (programQuestionnaireId === null)
            throw new Error("The parameter 'programQuestionnaireId' cannot be null.");
        else if (programQuestionnaireId !== undefined)
            url_ += "programQuestionnaireId=" + encodeURIComponent("" + programQuestionnaireId) + "&";
        if (programSurveyId === null)
            throw new Error("The parameter 'programSurveyId' cannot be null.");
        else if (programSurveyId !== undefined)
            url_ += "programSurveyId=" + encodeURIComponent("" + programSurveyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveProgramQuestionnaireById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveProgramQuestionnaireById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProgramQuestionnaireDataUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProgramQuestionnaireDataUsersResult>;
        }));
    }

    protected processRetrieveProgramQuestionnaireById(response: HttpResponseBase): Observable<ProgramQuestionnaireDataUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProgramQuestionnaireDataUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProgramQuestionnaireDataUsersResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insertProgramSurvey(body: InsertProgramSurveyRequestData | undefined): Observable<InsertIdResultInfo> {
        let url_ = this.baseUrl + "/api/ProgramSurvey/InsertProgramSurvey";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertProgramSurvey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertProgramSurvey(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertIdResultInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertIdResultInfo>;
        }));
    }

    protected processInsertProgramSurvey(response: HttpResponseBase): Observable<InsertIdResultInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertIdResultInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertIdResultInfo>(null as any);
    }

    /**
     * @return Success
     */
    fillProgramTypes(): Observable<ShortFillDataListUsersResult> {
        let url_ = this.baseUrl + "/api/ProgramType/FillProgramTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFillProgramTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFillProgramTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ShortFillDataListUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ShortFillDataListUsersResult>;
        }));
    }

    protected processFillProgramTypes(response: HttpResponseBase): Observable<ShortFillDataListUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShortFillDataListUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShortFillDataListUsersResult>(null as any);
    }

    /**
     * @return Success
     */
    fillRoles(): Observable<FillDataListUsersResult> {
        let url_ = this.baseUrl + "/api/Role/FillRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFillRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFillRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FillDataListUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FillDataListUsersResult>;
        }));
    }

    protected processFillRoles(response: HttpResponseBase): Observable<FillDataListUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FillDataListUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FillDataListUsersResult>(null as any);
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param trainerInvitationId (optional) 
     * @return Success
     */
    retrieveAllTrainerApplicationAttachmentsByTrainerInvitationId(pageIndex: number | undefined, pageSize: number | undefined, trainerInvitationId: number | undefined): Observable<TrainerApplicationAttachmentDataPagedModelUsersResult> {
        let url_ = this.baseUrl + "/api/TrainerApplicationAttachment/RetrieveAllTrainerApplicationAttachmentsByTrainerInvitationId?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (trainerInvitationId === null)
            throw new Error("The parameter 'trainerInvitationId' cannot be null.");
        else if (trainerInvitationId !== undefined)
            url_ += "trainerInvitationId=" + encodeURIComponent("" + trainerInvitationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveAllTrainerApplicationAttachmentsByTrainerInvitationId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveAllTrainerApplicationAttachmentsByTrainerInvitationId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainerApplicationAttachmentDataPagedModelUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainerApplicationAttachmentDataPagedModelUsersResult>;
        }));
    }

    protected processRetrieveAllTrainerApplicationAttachmentsByTrainerInvitationId(response: HttpResponseBase): Observable<TrainerApplicationAttachmentDataPagedModelUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainerApplicationAttachmentDataPagedModelUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainerApplicationAttachmentDataPagedModelUsersResult>(null as any);
    }

    /**
     * @param trainerApplicationAttachmentId (optional) 
     * @return Success
     */
    downloadTrainerApplicationAttachmentFile(trainerApplicationAttachmentId: number | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TrainerApplicationAttachment/DownloadTrainerApplicationAttachmentFile?";
        if (trainerApplicationAttachmentId === null)
            throw new Error("The parameter 'trainerApplicationAttachmentId' cannot be null.");
        else if (trainerApplicationAttachmentId !== undefined)
            url_ += "trainerApplicationAttachmentId=" + encodeURIComponent("" + trainerApplicationAttachmentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadTrainerApplicationAttachmentFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadTrainerApplicationAttachmentFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDownloadTrainerApplicationAttachmentFile(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    retrieveAllTrainerCertificatesByTrainerId(pageIndex: number | undefined, pageSize: number | undefined): Observable<SelectAllTrainerCertificatesDataPagedModelUsersResult> {
        let url_ = this.baseUrl + "/api/TrainerCertificate/RetrieveAllTrainerCertificatesByTrainerId?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveAllTrainerCertificatesByTrainerId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveAllTrainerCertificatesByTrainerId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectAllTrainerCertificatesDataPagedModelUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectAllTrainerCertificatesDataPagedModelUsersResult>;
        }));
    }

    protected processRetrieveAllTrainerCertificatesByTrainerId(response: HttpResponseBase): Observable<SelectAllTrainerCertificatesDataPagedModelUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SelectAllTrainerCertificatesDataPagedModelUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectAllTrainerCertificatesDataPagedModelUsersResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insertTrainerCertificate(body: InsertTrainerCertificateRequestData | undefined): Observable<InsertIdResultInfo> {
        let url_ = this.baseUrl + "/api/TrainerCertificate/InsertTrainerCertificate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertTrainerCertificate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertTrainerCertificate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertIdResultInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertIdResultInfo>;
        }));
    }

    protected processInsertTrainerCertificate(response: HttpResponseBase): Observable<InsertIdResultInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertIdResultInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertIdResultInfo>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTrainerCertificate(body: TrainerCertificateData | undefined): Observable<DbResultInfo> {
        let url_ = this.baseUrl + "/api/TrainerCertificate/UpdateTrainerCertificate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTrainerCertificate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTrainerCertificate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DbResultInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DbResultInfo>;
        }));
    }

    protected processUpdateTrainerCertificate(response: HttpResponseBase): Observable<DbResultInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DbResultInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DbResultInfo>(null as any);
    }

    /**
     * @param trainerCertificateId (optional) 
     * @return Success
     */
    retrieveOneTrainerCertificateById(trainerCertificateId: number | undefined): Observable<TrainerCertificateDataUsersResult> {
        let url_ = this.baseUrl + "/api/TrainerCertificate/RetrieveOneTrainerCertificateById?";
        if (trainerCertificateId === null)
            throw new Error("The parameter 'trainerCertificateId' cannot be null.");
        else if (trainerCertificateId !== undefined)
            url_ += "trainerCertificateId=" + encodeURIComponent("" + trainerCertificateId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveOneTrainerCertificateById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveOneTrainerCertificateById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainerCertificateDataUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainerCertificateDataUsersResult>;
        }));
    }

    protected processRetrieveOneTrainerCertificateById(response: HttpResponseBase): Observable<TrainerCertificateDataUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainerCertificateDataUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainerCertificateDataUsersResult>(null as any);
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    retrieveAllCertifiedTrainersForRegister(pageIndex: number | undefined, pageSize: number | undefined): Observable<SelectAllTrainerCertificatesForRegisterDataPagedModelUsersResult> {
        let url_ = this.baseUrl + "/api/TrainerCertificate/RetrieveAllCertifiedTrainersForRegister?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveAllCertifiedTrainersForRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveAllCertifiedTrainersForRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectAllTrainerCertificatesForRegisterDataPagedModelUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectAllTrainerCertificatesForRegisterDataPagedModelUsersResult>;
        }));
    }

    protected processRetrieveAllCertifiedTrainersForRegister(response: HttpResponseBase): Observable<SelectAllTrainerCertificatesForRegisterDataPagedModelUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SelectAllTrainerCertificatesForRegisterDataPagedModelUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectAllTrainerCertificatesForRegisterDataPagedModelUsersResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insertTrainerCertificateRenewalRequest(body: InsertTrainerCertificateRenewalRequestData | undefined): Observable<InsertIdResultInfo> {
        let url_ = this.baseUrl + "/api/TrainerCertificateRenewalRequest/InsertTrainerCertificateRenewalRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertTrainerCertificateRenewalRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertTrainerCertificateRenewalRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertIdResultInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertIdResultInfo>;
        }));
    }

    protected processInsertTrainerCertificateRenewalRequest(response: HttpResponseBase): Observable<InsertIdResultInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertIdResultInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertIdResultInfo>(null as any);
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param applicationStatusId (optional) 
     * @param programTypeId (optional) 
     * @return Success
     */
    retrieveAllTrainerInvitationsByTrainerId(pageIndex: number | undefined, pageSize: number | undefined, applicationStatusId: number | undefined, programTypeId: number | undefined): Observable<TrainerInvitationDataPagedModelUsersResult> {
        let url_ = this.baseUrl + "/api/TrainerInvitation/RetrieveAllTrainerInvitationsByTrainerId?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (applicationStatusId === null)
            throw new Error("The parameter 'applicationStatusId' cannot be null.");
        else if (applicationStatusId !== undefined)
            url_ += "applicationStatusId=" + encodeURIComponent("" + applicationStatusId) + "&";
        if (programTypeId === null)
            throw new Error("The parameter 'programTypeId' cannot be null.");
        else if (programTypeId !== undefined)
            url_ += "programTypeId=" + encodeURIComponent("" + programTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveAllTrainerInvitationsByTrainerId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveAllTrainerInvitationsByTrainerId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainerInvitationDataPagedModelUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainerInvitationDataPagedModelUsersResult>;
        }));
    }

    protected processRetrieveAllTrainerInvitationsByTrainerId(response: HttpResponseBase): Observable<TrainerInvitationDataPagedModelUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainerInvitationDataPagedModelUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainerInvitationDataPagedModelUsersResult>(null as any);
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param active (optional) 
     * @param programTypeId (optional) 
     * @param year (optional) 
     * @return Success
     */
    retrieveAllTrainerInvitationsByTrainerIdForMaterials(pageIndex: number | undefined, pageSize: number | undefined, active: boolean | null | undefined, programTypeId: number | undefined, year: number | null | undefined): Observable<TrainerInvitationForMaterialsDataPagedModelUsersResult> {
        let url_ = this.baseUrl + "/api/TrainerInvitation/RetrieveAllTrainerInvitationsByTrainerIdForMaterials?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (active !== undefined && active !== null)
            url_ += "active=" + encodeURIComponent("" + active) + "&";
        if (programTypeId === null)
            throw new Error("The parameter 'programTypeId' cannot be null.");
        else if (programTypeId !== undefined)
            url_ += "programTypeId=" + encodeURIComponent("" + programTypeId) + "&";
        if (year !== undefined && year !== null)
            url_ += "year=" + encodeURIComponent("" + year) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveAllTrainerInvitationsByTrainerIdForMaterials(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveAllTrainerInvitationsByTrainerIdForMaterials(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainerInvitationForMaterialsDataPagedModelUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainerInvitationForMaterialsDataPagedModelUsersResult>;
        }));
    }

    protected processRetrieveAllTrainerInvitationsByTrainerIdForMaterials(response: HttpResponseBase): Observable<TrainerInvitationForMaterialsDataPagedModelUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainerInvitationForMaterialsDataPagedModelUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainerInvitationForMaterialsDataPagedModelUsersResult>(null as any);
    }

    /**
     * @param trainerInvitationId (optional) 
     * @return Success
     */
    acceptTrainerInvitation(trainerInvitationId: number | undefined): Observable<DbResultInfo> {
        let url_ = this.baseUrl + "/api/TrainerInvitation/AcceptTrainerInvitation?";
        if (trainerInvitationId === null)
            throw new Error("The parameter 'trainerInvitationId' cannot be null.");
        else if (trainerInvitationId !== undefined)
            url_ += "trainerInvitationId=" + encodeURIComponent("" + trainerInvitationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAcceptTrainerInvitation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAcceptTrainerInvitation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DbResultInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DbResultInfo>;
        }));
    }

    protected processAcceptTrainerInvitation(response: HttpResponseBase): Observable<DbResultInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DbResultInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DbResultInfo>(null as any);
    }

    /**
     * @param trainerInvitationId (optional) 
     * @param cancelledDescription (optional) 
     * @param cancelledWithDocuments (optional) 
     * @param fileDescriptions (optional) 
     * @param files (optional) 
     * @return Success
     */
    cancelTrainerInvitation(trainerInvitationId: number | undefined, cancelledDescription: string | null | undefined, cancelledWithDocuments: boolean | undefined, fileDescriptions: string[] | null | undefined, files: FileParameter[] | null | undefined): Observable<DbResultInfo> {
        let url_ = this.baseUrl + "/api/TrainerInvitation/CancelTrainerInvitation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (trainerInvitationId === null || trainerInvitationId === undefined)
            throw new Error("The parameter 'trainerInvitationId' cannot be null.");
        else
            content_.append("TrainerInvitationId", trainerInvitationId.toString());
        if (cancelledDescription !== null && cancelledDescription !== undefined)
            content_.append("CancelledDescription", cancelledDescription.toString());
        if (cancelledWithDocuments === null || cancelledWithDocuments === undefined)
            throw new Error("The parameter 'cancelledWithDocuments' cannot be null.");
        else
            content_.append("CancelledWithDocuments", cancelledWithDocuments.toString());
        if (fileDescriptions !== null && fileDescriptions !== undefined)
            fileDescriptions.forEach(item_ => content_.append("fileDescriptions", item_.toString()));
        if (files !== null && files !== undefined)
            files.forEach(item_ => content_.append("files", item_.data, item_.fileName ? item_.fileName : "files") );

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelTrainerInvitation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelTrainerInvitation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DbResultInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DbResultInfo>;
        }));
    }

    protected processCancelTrainerInvitation(response: HttpResponseBase): Observable<DbResultInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DbResultInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DbResultInfo>(null as any);
    }

    /**
     * @param trainerInvitationId (optional) 
     * @return Success
     */
    retrieveOneTrainerInvitationById(trainerInvitationId: number | undefined): Observable<SelectOneTrainerInvitationDataUsersResult> {
        let url_ = this.baseUrl + "/api/TrainerInvitation/RetrieveOneTrainerInvitationById?";
        if (trainerInvitationId === null)
            throw new Error("The parameter 'trainerInvitationId' cannot be null.");
        else if (trainerInvitationId !== undefined)
            url_ += "trainerInvitationId=" + encodeURIComponent("" + trainerInvitationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveOneTrainerInvitationById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveOneTrainerInvitationById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectOneTrainerInvitationDataUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectOneTrainerInvitationDataUsersResult>;
        }));
    }

    protected processRetrieveOneTrainerInvitationById(response: HttpResponseBase): Observable<SelectOneTrainerInvitationDataUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SelectOneTrainerInvitationDataUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectOneTrainerInvitationDataUsersResult>(null as any);
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    retrieveActiveTrainerQuestionnaire(pageIndex: number | undefined, pageSize: number | undefined): Observable<TrainerQuestionnaireDataUsersResult> {
        let url_ = this.baseUrl + "/api/TrainerQuestionnaire/RetrieveActiveTrainerQuestionnaire?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveActiveTrainerQuestionnaire(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveActiveTrainerQuestionnaire(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainerQuestionnaireDataUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainerQuestionnaireDataUsersResult>;
        }));
    }

    protected processRetrieveActiveTrainerQuestionnaire(response: HttpResponseBase): Observable<TrainerQuestionnaireDataUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainerQuestionnaireDataUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainerQuestionnaireDataUsersResult>(null as any);
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param trainerQuestionnaireId (optional) 
     * @param trainerSurveyId (optional) 
     * @return Success
     */
    retrieveTrainerQuestionnaireById(pageIndex: number | undefined, pageSize: number | undefined, trainerQuestionnaireId: number | undefined, trainerSurveyId: number | undefined): Observable<TrainerQuestionnaireDataUsersResult> {
        let url_ = this.baseUrl + "/api/TrainerQuestionnaire/RetrieveTrainerQuestionnaireById?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (trainerQuestionnaireId === null)
            throw new Error("The parameter 'trainerQuestionnaireId' cannot be null.");
        else if (trainerQuestionnaireId !== undefined)
            url_ += "trainerQuestionnaireId=" + encodeURIComponent("" + trainerQuestionnaireId) + "&";
        if (trainerSurveyId === null)
            throw new Error("The parameter 'trainerSurveyId' cannot be null.");
        else if (trainerSurveyId !== undefined)
            url_ += "trainerSurveyId=" + encodeURIComponent("" + trainerSurveyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveTrainerQuestionnaireById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveTrainerQuestionnaireById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainerQuestionnaireDataUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainerQuestionnaireDataUsersResult>;
        }));
    }

    protected processRetrieveTrainerQuestionnaireById(response: HttpResponseBase): Observable<TrainerQuestionnaireDataUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainerQuestionnaireDataUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainerQuestionnaireDataUsersResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insertTrainerSurvey(body: InsertTrainerSurveyRequestData | undefined): Observable<InsertIdResultInfo> {
        let url_ = this.baseUrl + "/api/TrainerSurvey/InsertTrainerSurvey";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertTrainerSurvey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertTrainerSurvey(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertIdResultInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertIdResultInfo>;
        }));
    }

    protected processInsertTrainerSurvey(response: HttpResponseBase): Observable<InsertIdResultInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertIdResultInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertIdResultInfo>(null as any);
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    retrieveAllTrainerWorkExperienceByTrainerId(pageIndex: number | undefined, pageSize: number | undefined): Observable<TrainerWorkExperienceDataPagedModelUsersResult> {
        let url_ = this.baseUrl + "/api/TrainerWorkExperience/RetrieveAllTrainerWorkExperienceByTrainerId?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveAllTrainerWorkExperienceByTrainerId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveAllTrainerWorkExperienceByTrainerId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainerWorkExperienceDataPagedModelUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainerWorkExperienceDataPagedModelUsersResult>;
        }));
    }

    protected processRetrieveAllTrainerWorkExperienceByTrainerId(response: HttpResponseBase): Observable<TrainerWorkExperienceDataPagedModelUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainerWorkExperienceDataPagedModelUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainerWorkExperienceDataPagedModelUsersResult>(null as any);
    }

    /**
     * @param trainerWorkExperienceId (optional) 
     * @return Success
     */
    retrieveOneTrainerWorkExperienceById(trainerWorkExperienceId: number | undefined): Observable<TrainerWorkExperienceDataUsersResult> {
        let url_ = this.baseUrl + "/api/TrainerWorkExperience/RetrieveOneTrainerWorkExperienceById?";
        if (trainerWorkExperienceId === null)
            throw new Error("The parameter 'trainerWorkExperienceId' cannot be null.");
        else if (trainerWorkExperienceId !== undefined)
            url_ += "trainerWorkExperienceId=" + encodeURIComponent("" + trainerWorkExperienceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveOneTrainerWorkExperienceById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveOneTrainerWorkExperienceById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainerWorkExperienceDataUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainerWorkExperienceDataUsersResult>;
        }));
    }

    protected processRetrieveOneTrainerWorkExperienceById(response: HttpResponseBase): Observable<TrainerWorkExperienceDataUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainerWorkExperienceDataUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainerWorkExperienceDataUsersResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTrainerWorkExperience(body: TrainerWorkExperienceData | undefined): Observable<DbResultInfo> {
        let url_ = this.baseUrl + "/api/TrainerWorkExperience/UpdateTrainerWorkExperience";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTrainerWorkExperience(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTrainerWorkExperience(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DbResultInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DbResultInfo>;
        }));
    }

    protected processUpdateTrainerWorkExperience(response: HttpResponseBase): Observable<DbResultInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DbResultInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DbResultInfo>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insertTrainerWorkExperience(body: TrainerWorkExperienceData | undefined): Observable<InsertIdResultInfo> {
        let url_ = this.baseUrl + "/api/TrainerWorkExperience/InsertTrainerWorkExperience";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertTrainerWorkExperience(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertTrainerWorkExperience(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertIdResultInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertIdResultInfo>;
        }));
    }

    protected processInsertTrainerWorkExperience(response: HttpResponseBase): Observable<InsertIdResultInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertIdResultInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertIdResultInfo>(null as any);
    }

    /**
     * @param trainerWorkExperienceId (optional) 
     * @return Success
     */
    deleteTrainerWorkExperience(trainerWorkExperienceId: number | undefined): Observable<DbResultInfo> {
        let url_ = this.baseUrl + "/api/TrainerWorkExperience/DeleteTrainerWorkExperience?";
        if (trainerWorkExperienceId === null)
            throw new Error("The parameter 'trainerWorkExperienceId' cannot be null.");
        else if (trainerWorkExperienceId !== undefined)
            url_ += "trainerWorkExperienceId=" + encodeURIComponent("" + trainerWorkExperienceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTrainerWorkExperience(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTrainerWorkExperience(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DbResultInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DbResultInfo>;
        }));
    }

    protected processDeleteTrainerWorkExperience(response: HttpResponseBase): Observable<DbResultInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DbResultInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DbResultInfo>(null as any);
    }

    /**
     * @param searchParam (optional) 
     * @param isBRO (optional) 
     * @return Success
     */
    fillTrainingProviders(searchParam: string | null | undefined, isBRO: boolean | null | undefined): Observable<FillDataListUsersResult> {
        let url_ = this.baseUrl + "/api/TrainingProvider/FillTrainingProviders?";
        if (searchParam !== undefined && searchParam !== null)
            url_ += "searchParam=" + encodeURIComponent("" + searchParam) + "&";
        if (isBRO !== undefined && isBRO !== null)
            url_ += "isBRO=" + encodeURIComponent("" + isBRO) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFillTrainingProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFillTrainingProviders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FillDataListUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FillDataListUsersResult>;
        }));
    }

    protected processFillTrainingProviders(response: HttpResponseBase): Observable<FillDataListUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FillDataListUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FillDataListUsersResult>(null as any);
    }

    /**
     * @param key (optional) 
     * @param code (optional) 
     * @return Success
     */
    verifyEmail(key: number | undefined, code: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/User/VerifyEmail?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        if (code !== undefined && code !== null)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifyEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifyEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processVerifyEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    login(body: LoginRequestData | undefined): Observable<LoginUserDataSecurityResult> {
        let url_ = this.baseUrl + "/api/User/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoginUserDataSecurityResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoginUserDataSecurityResult>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<LoginUserDataSecurityResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginUserDataSecurityResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoginUserDataSecurityResult>(null as any);
    }

    /**
     * @return Success
     */
    signout(): Observable<SecurityResultStatus> {
        let url_ = this.baseUrl + "/api/User/Signout";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSignout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSignout(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SecurityResultStatus>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SecurityResultStatus>;
        }));
    }

    protected processSignout(response: HttpResponseBase): Observable<SecurityResultStatus> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SecurityResultStatus>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordRequestData | undefined): Observable<SecurityResultStatus> {
        let url_ = this.baseUrl + "/api/User/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SecurityResultStatus>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SecurityResultStatus>;
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<SecurityResultStatus> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SecurityResultStatus>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    forgotPassword(body: ForgotPasswordRequestData | undefined): Observable<SecurityResultStatus> {
        let url_ = this.baseUrl + "/api/User/ForgotPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForgotPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgotPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SecurityResultStatus>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SecurityResultStatus>;
        }));
    }

    protected processForgotPassword(response: HttpResponseBase): Observable<SecurityResultStatus> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SecurityResultStatus>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResetPasswordRequestData | undefined): Observable<SecurityResultStatus> {
        let url_ = this.baseUrl + "/api/User/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SecurityResultStatus>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SecurityResultStatus>;
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<SecurityResultStatus> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SecurityResultStatus>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    registerParticipant(body: ParticipantRegistrationData | undefined): Observable<InsertIdResultInfo> {
        let url_ = this.baseUrl + "/api/User/RegisterParticipant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterParticipant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterParticipant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InsertIdResultInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InsertIdResultInfo>;
        }));
    }

    protected processRegisterParticipant(response: HttpResponseBase): Observable<InsertIdResultInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InsertIdResultInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InsertIdResultInfo>(null as any);
    }

    /**
     * @return Success
     */
    retrieveParticipantProfile(): Observable<ParticipantProfileDataUsersResult> {
        let url_ = this.baseUrl + "/api/User/RetrieveParticipantProfile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveParticipantProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveParticipantProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ParticipantProfileDataUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ParticipantProfileDataUsersResult>;
        }));
    }

    protected processRetrieveParticipantProfile(response: HttpResponseBase): Observable<ParticipantProfileDataUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ParticipantProfileDataUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ParticipantProfileDataUsersResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateParticipantProfile(body: ParticipantProfileData | undefined): Observable<DbResultInfo> {
        let url_ = this.baseUrl + "/api/User/UpdateParticipantProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateParticipantProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateParticipantProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DbResultInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DbResultInfo>;
        }));
    }

    protected processUpdateParticipantProfile(response: HttpResponseBase): Observable<DbResultInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DbResultInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DbResultInfo>(null as any);
    }

    /**
     * @return Success
     */
    retrieveTrainerProfile(): Observable<TrainerProfileDataUsersResult> {
        let url_ = this.baseUrl + "/api/User/RetrieveTrainerProfile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveTrainerProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveTrainerProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TrainerProfileDataUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TrainerProfileDataUsersResult>;
        }));
    }

    protected processRetrieveTrainerProfile(response: HttpResponseBase): Observable<TrainerProfileDataUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TrainerProfileDataUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrainerProfileDataUsersResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTrainerProfile(body: TrainerProfileData | undefined): Observable<DbResultInfo> {
        let url_ = this.baseUrl + "/api/User/UpdateTrainerProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTrainerProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTrainerProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DbResultInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DbResultInfo>;
        }));
    }

    protected processUpdateTrainerProfile(response: HttpResponseBase): Observable<DbResultInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DbResultInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DbResultInfo>(null as any);
    }

    /**
     * @return Success
     */
    retrieveCommissionProfile(): Observable<CommissionProfileDataUsersResult> {
        let url_ = this.baseUrl + "/api/User/RetrieveCommissionProfile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRetrieveCommissionProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRetrieveCommissionProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommissionProfileDataUsersResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommissionProfileDataUsersResult>;
        }));
    }

    protected processRetrieveCommissionProfile(response: HttpResponseBase): Observable<CommissionProfileDataUsersResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommissionProfileDataUsersResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommissionProfileDataUsersResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCommissionProfile(body: CommissionProfileData | undefined): Observable<DbResultInfo> {
        let url_ = this.baseUrl + "/api/User/UpdateCommissionProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCommissionProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCommissionProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DbResultInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DbResultInfo>;
        }));
    }

    protected processUpdateCommissionProfile(response: HttpResponseBase): Observable<DbResultInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DbResultInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DbResultInfo>(null as any);
    }
}

export enum UsersResultStatus {
    Success = "Success",
    ServerError = "ServerError",
    ArgumentsException = "ArgumentsException",
    NotFound = "NotFound",
    WrongCreditials = "WrongCreditials",
    UserNotValidated = "UserNotValidated",
    Error = "Error",
    NotAuthenticated = "NotAuthenticated",
    RoomIntervalsOverlap = "RoomIntervalsOverlap",
    EmailAlreadyTaken = "EmailAlreadyTaken",
    InstallmentDoesNotExistOrAlreadyPaid = "InstallmentDoesNotExistOrAlreadyPaid",
    StudentCardNotFound = "StudentCardNotFound",
    StudentCardAppInsufficientFunds = "StudentCardAppInsufficientFunds",
}

export class SelectAllApplicationAttachmentsData implements ISelectAllApplicationAttachmentsData {
    id?: number;
    programApplicationId?: number;
    name?: string | undefined;
    fileName?: string | undefined;
    path?: string | undefined;
    timeIns?: Date;
    userIdIns?: number | undefined;

    constructor(data?: ISelectAllApplicationAttachmentsData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.programApplicationId = _data["programApplicationId"];
            this.name = _data["name"];
            this.fileName = _data["fileName"];
            this.path = _data["path"];
            this.timeIns = _data["timeIns"] ? new Date(_data["timeIns"].toString()) : <any>undefined;
            this.userIdIns = _data["userIdIns"];
        }
    }

    static fromJS(data: any): SelectAllApplicationAttachmentsData {
        data = typeof data === 'object' ? data : {};
        let result = new SelectAllApplicationAttachmentsData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["programApplicationId"] = this.programApplicationId;
        data["name"] = this.name;
        data["fileName"] = this.fileName;
        data["path"] = this.path;
        data["timeIns"] = this.timeIns ? this.timeIns.toISOString() : <any>undefined;
        data["userIdIns"] = this.userIdIns;
        return data;
    }
}

export interface ISelectAllApplicationAttachmentsData {
    id?: number;
    programApplicationId?: number;
    name?: string | undefined;
    fileName?: string | undefined;
    path?: string | undefined;
    timeIns?: Date;
    userIdIns?: number | undefined;
}

export class SelectAllApplicationAttachmentsDataPagedModel implements ISelectAllApplicationAttachmentsDataPagedModel {
    totalItems?: number;
    items?: SelectAllApplicationAttachmentsData[] | undefined;

    constructor(data?: ISelectAllApplicationAttachmentsDataPagedModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItems = _data["totalItems"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SelectAllApplicationAttachmentsData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SelectAllApplicationAttachmentsDataPagedModel {
        data = typeof data === 'object' ? data : {};
        let result = new SelectAllApplicationAttachmentsDataPagedModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItems"] = this.totalItems;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISelectAllApplicationAttachmentsDataPagedModel {
    totalItems?: number;
    items?: SelectAllApplicationAttachmentsData[] | undefined;
}

export class SelectAllApplicationAttachmentsDataPagedModelUsersResult implements ISelectAllApplicationAttachmentsDataPagedModelUsersResult {
    status?: UsersResultStatus;
    content?: SelectAllApplicationAttachmentsDataPagedModel;

    constructor(data?: ISelectAllApplicationAttachmentsDataPagedModelUsersResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.content = _data["content"] ? SelectAllApplicationAttachmentsDataPagedModel.fromJS(_data["content"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SelectAllApplicationAttachmentsDataPagedModelUsersResult {
        data = typeof data === 'object' ? data : {};
        let result = new SelectAllApplicationAttachmentsDataPagedModelUsersResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISelectAllApplicationAttachmentsDataPagedModelUsersResult {
    status?: UsersResultStatus;
    content?: SelectAllApplicationAttachmentsDataPagedModel;
}

export class ShortFillData implements IShortFillData {
    id?: number;
    name?: string | undefined;

    constructor(data?: IShortFillData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ShortFillData {
        data = typeof data === 'object' ? data : {};
        let result = new ShortFillData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IShortFillData {
    id?: number;
    name?: string | undefined;
}

export class ShortFillDataListUsersResult implements IShortFillDataListUsersResult {
    status?: UsersResultStatus;
    content?: ShortFillData[] | undefined;

    constructor(data?: IShortFillDataListUsersResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            if (Array.isArray(_data["content"])) {
                this.content = [] as any;
                for (let item of _data["content"])
                    this.content!.push(ShortFillData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ShortFillDataListUsersResult {
        data = typeof data === 'object' ? data : {};
        let result = new ShortFillDataListUsersResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        if (Array.isArray(this.content)) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item.toJSON());
        }
        return data;
    }
}

export interface IShortFillDataListUsersResult {
    status?: UsersResultStatus;
    content?: ShortFillData[] | undefined;
}

export class FillCityData implements IFillCityData {
    id?: number;
    name?: string | undefined;
    postCode?: number;

    constructor(data?: IFillCityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.postCode = _data["postCode"];
        }
    }

    static fromJS(data: any): FillCityData {
        data = typeof data === 'object' ? data : {};
        let result = new FillCityData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["postCode"] = this.postCode;
        return data;
    }
}

export interface IFillCityData {
    id?: number;
    name?: string | undefined;
    postCode?: number;
}

export class FillCityDataListUsersResult implements IFillCityDataListUsersResult {
    status?: UsersResultStatus;
    content?: FillCityData[] | undefined;

    constructor(data?: IFillCityDataListUsersResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            if (Array.isArray(_data["content"])) {
                this.content = [] as any;
                for (let item of _data["content"])
                    this.content!.push(FillCityData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FillCityDataListUsersResult {
        data = typeof data === 'object' ? data : {};
        let result = new FillCityDataListUsersResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        if (Array.isArray(this.content)) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item.toJSON());
        }
        return data;
    }
}

export interface IFillCityDataListUsersResult {
    status?: UsersResultStatus;
    content?: FillCityData[] | undefined;
}

export class CommissionApplicationAttachmentData implements ICommissionApplicationAttachmentData {
    id?: number;
    commissionInvitationId?: number;
    name?: string | undefined;
    fileName?: string | undefined;
    path?: string | undefined;
    timeIns?: Date;
    userIdIns?: number | undefined;

    constructor(data?: ICommissionApplicationAttachmentData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.commissionInvitationId = _data["commissionInvitationId"];
            this.name = _data["name"];
            this.fileName = _data["fileName"];
            this.path = _data["path"];
            this.timeIns = _data["timeIns"] ? new Date(_data["timeIns"].toString()) : <any>undefined;
            this.userIdIns = _data["userIdIns"];
        }
    }

    static fromJS(data: any): CommissionApplicationAttachmentData {
        data = typeof data === 'object' ? data : {};
        let result = new CommissionApplicationAttachmentData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["commissionInvitationId"] = this.commissionInvitationId;
        data["name"] = this.name;
        data["fileName"] = this.fileName;
        data["path"] = this.path;
        data["timeIns"] = this.timeIns ? this.timeIns.toISOString() : <any>undefined;
        data["userIdIns"] = this.userIdIns;
        return data;
    }
}

export interface ICommissionApplicationAttachmentData {
    id?: number;
    commissionInvitationId?: number;
    name?: string | undefined;
    fileName?: string | undefined;
    path?: string | undefined;
    timeIns?: Date;
    userIdIns?: number | undefined;
}

export class CommissionApplicationAttachmentDataPagedModel implements ICommissionApplicationAttachmentDataPagedModel {
    totalItems?: number;
    items?: CommissionApplicationAttachmentData[] | undefined;

    constructor(data?: ICommissionApplicationAttachmentDataPagedModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItems = _data["totalItems"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CommissionApplicationAttachmentData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CommissionApplicationAttachmentDataPagedModel {
        data = typeof data === 'object' ? data : {};
        let result = new CommissionApplicationAttachmentDataPagedModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItems"] = this.totalItems;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICommissionApplicationAttachmentDataPagedModel {
    totalItems?: number;
    items?: CommissionApplicationAttachmentData[] | undefined;
}

export class CommissionApplicationAttachmentDataPagedModelUsersResult implements ICommissionApplicationAttachmentDataPagedModelUsersResult {
    status?: UsersResultStatus;
    content?: CommissionApplicationAttachmentDataPagedModel;

    constructor(data?: ICommissionApplicationAttachmentDataPagedModelUsersResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.content = _data["content"] ? CommissionApplicationAttachmentDataPagedModel.fromJS(_data["content"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CommissionApplicationAttachmentDataPagedModelUsersResult {
        data = typeof data === 'object' ? data : {};
        let result = new CommissionApplicationAttachmentDataPagedModelUsersResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICommissionApplicationAttachmentDataPagedModelUsersResult {
    status?: UsersResultStatus;
    content?: CommissionApplicationAttachmentDataPagedModel;
}

export class CommissionInvitationData implements ICommissionInvitationData {
    id?: number;
    programId?: number;
    commissionId?: number;
    applicationStatusId?: number;
    cancelledDate?: Date | undefined;
    cancelledDescription?: string | undefined;
    invitationDate?: Date | undefined;
    invitationSentUserId?: number | undefined;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
    answerDate?: Date | undefined;
    justificationAccepted?: boolean | undefined;
    decisionDate?: Date | undefined;
    cancelledWithDocuments?: boolean | undefined;
    programName?: string | undefined;

    constructor(data?: ICommissionInvitationData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.programId = _data["programId"];
            this.commissionId = _data["commissionId"];
            this.applicationStatusId = _data["applicationStatusId"];
            this.cancelledDate = _data["cancelledDate"] ? new Date(_data["cancelledDate"].toString()) : <any>undefined;
            this.cancelledDescription = _data["cancelledDescription"];
            this.invitationDate = _data["invitationDate"] ? new Date(_data["invitationDate"].toString()) : <any>undefined;
            this.invitationSentUserId = _data["invitationSentUserId"];
            this.userIdIns = _data["userIdIns"];
            this.timeIns = _data["timeIns"] ? new Date(_data["timeIns"].toString()) : <any>undefined;
            this.userIdChg = _data["userIdChg"];
            this.timeChg = _data["timeChg"] ? new Date(_data["timeChg"].toString()) : <any>undefined;
            this.answerDate = _data["answerDate"] ? new Date(_data["answerDate"].toString()) : <any>undefined;
            this.justificationAccepted = _data["justificationAccepted"];
            this.decisionDate = _data["decisionDate"] ? new Date(_data["decisionDate"].toString()) : <any>undefined;
            this.cancelledWithDocuments = _data["cancelledWithDocuments"];
            this.programName = _data["programName"];
        }
    }

    static fromJS(data: any): CommissionInvitationData {
        data = typeof data === 'object' ? data : {};
        let result = new CommissionInvitationData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["programId"] = this.programId;
        data["commissionId"] = this.commissionId;
        data["applicationStatusId"] = this.applicationStatusId;
        data["cancelledDate"] = this.cancelledDate ? this.cancelledDate.toISOString() : <any>undefined;
        data["cancelledDescription"] = this.cancelledDescription;
        data["invitationDate"] = this.invitationDate ? this.invitationDate.toISOString() : <any>undefined;
        data["invitationSentUserId"] = this.invitationSentUserId;
        data["userIdIns"] = this.userIdIns;
        data["timeIns"] = this.timeIns ? this.timeIns.toISOString() : <any>undefined;
        data["userIdChg"] = this.userIdChg;
        data["timeChg"] = this.timeChg ? this.timeChg.toISOString() : <any>undefined;
        data["answerDate"] = this.answerDate ? this.answerDate.toISOString() : <any>undefined;
        data["justificationAccepted"] = this.justificationAccepted;
        data["decisionDate"] = this.decisionDate ? this.decisionDate.toISOString() : <any>undefined;
        data["cancelledWithDocuments"] = this.cancelledWithDocuments;
        data["programName"] = this.programName;
        return data;
    }
}

export interface ICommissionInvitationData {
    id?: number;
    programId?: number;
    commissionId?: number;
    applicationStatusId?: number;
    cancelledDate?: Date | undefined;
    cancelledDescription?: string | undefined;
    invitationDate?: Date | undefined;
    invitationSentUserId?: number | undefined;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
    answerDate?: Date | undefined;
    justificationAccepted?: boolean | undefined;
    decisionDate?: Date | undefined;
    cancelledWithDocuments?: boolean | undefined;
    programName?: string | undefined;
}

export class CommissionInvitationDataPagedModel implements ICommissionInvitationDataPagedModel {
    totalItems?: number;
    items?: CommissionInvitationData[] | undefined;

    constructor(data?: ICommissionInvitationDataPagedModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItems = _data["totalItems"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CommissionInvitationData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CommissionInvitationDataPagedModel {
        data = typeof data === 'object' ? data : {};
        let result = new CommissionInvitationDataPagedModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItems"] = this.totalItems;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICommissionInvitationDataPagedModel {
    totalItems?: number;
    items?: CommissionInvitationData[] | undefined;
}

export class CommissionInvitationDataPagedModelUsersResult implements ICommissionInvitationDataPagedModelUsersResult {
    status?: UsersResultStatus;
    content?: CommissionInvitationDataPagedModel;

    constructor(data?: ICommissionInvitationDataPagedModelUsersResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.content = _data["content"] ? CommissionInvitationDataPagedModel.fromJS(_data["content"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CommissionInvitationDataPagedModelUsersResult {
        data = typeof data === 'object' ? data : {};
        let result = new CommissionInvitationDataPagedModelUsersResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICommissionInvitationDataPagedModelUsersResult {
    status?: UsersResultStatus;
    content?: CommissionInvitationDataPagedModel;
}

export enum DbStatusCode {
    Success = "Success",
    RecordExist = "RecordExist",
    InvalidOperation = "InvalidOperation",
    NoFreePlaces = "NoFreePlaces",
    SendMailFailed = "SendMailFailed",
    NoExamFound = "NoExamFound",
    NoValidCertificate = "NoValidCertificate",
    AlreadyApplied = "AlreadyApplied",
    Prohibition = "Prohibition",
    InconsistentProgramDays = "InconsistentProgramDays",
    AccessDenied = "AccessDenied",
    InvalidRequest = "InvalidRequest",
    OnlyOneCorrectAnswer = "OnlyOneCorrectAnswer",
    ProgramHasStarted = "ProgramHasStarted",
    NotEnoughQuestions = "NotEnoughQuestions",
    RegistrationTimeOver = "RegistrationTimeOver",
    TooLargeProgramDaysMin = "TooLargeProgramDaysMin",
    CommissionGroupLimit = "CommissionGroupLimit",
    TrainerGroupLimit = "TrainerGroupLimit",
    ActiveRenewalRequestExists = "ActiveRenewalRequestExists",
    NotTheNewestCertificate = "NotTheNewestCertificate",
    CertificationGroupLimit = "CertificationGroupLimit",
    RecertificationGroupLimit = "RecertificationGroupLimit",
    JustificationNotReviewed = "JustificationNotReviewed",
    HasValidCertificate = "HasValidCertificate",
    NoActiveTrainerInvitation = "NoActiveTrainerInvitation",
    NotEnoughQuestionsForEQC = "NotEnoughQuestionsForEQC",
    NotEnoughQuestionsForEC = "NotEnoughQuestionsForEC",
    InvoiceIsStorned = "InvoiceIsStorned",
    RecertificationApplyingLimit = "RecertificationApplyingLimit",
    TestHasNotStarted = "TestHasNotStarted",
    Error = "Error",
}

export class DbResultInfo implements IDbResultInfo {
    statusCode?: DbStatusCode;

    constructor(data?: IDbResultInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
        }
    }

    static fromJS(data: any): DbResultInfo {
        data = typeof data === 'object' ? data : {};
        let result = new DbResultInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        return data;
    }
}

export interface IDbResultInfo {
    statusCode?: DbStatusCode;
}

export class SelectOneCommissionInvitationData implements ISelectOneCommissionInvitationData {
    id?: number;
    programId?: number;
    commissionId?: number;
    applicationStatusId?: number;
    cancelledDate?: Date | undefined;
    cancelledDescription?: string | undefined;
    invitationDate?: Date | undefined;
    invitationSentUserId?: number | undefined;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
    answerDate?: Date | undefined;
    decisionDescription?: string | undefined;
    justificationAccepted?: boolean | undefined;
    decisionDate?: Date | undefined;
    cancelledWithDocuments?: boolean | undefined;
    programName?: string | undefined;
    programTypeId?: number;

    constructor(data?: ISelectOneCommissionInvitationData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.programId = _data["programId"];
            this.commissionId = _data["commissionId"];
            this.applicationStatusId = _data["applicationStatusId"];
            this.cancelledDate = _data["cancelledDate"] ? new Date(_data["cancelledDate"].toString()) : <any>undefined;
            this.cancelledDescription = _data["cancelledDescription"];
            this.invitationDate = _data["invitationDate"] ? new Date(_data["invitationDate"].toString()) : <any>undefined;
            this.invitationSentUserId = _data["invitationSentUserId"];
            this.userIdIns = _data["userIdIns"];
            this.timeIns = _data["timeIns"] ? new Date(_data["timeIns"].toString()) : <any>undefined;
            this.userIdChg = _data["userIdChg"];
            this.timeChg = _data["timeChg"] ? new Date(_data["timeChg"].toString()) : <any>undefined;
            this.answerDate = _data["answerDate"] ? new Date(_data["answerDate"].toString()) : <any>undefined;
            this.decisionDescription = _data["decisionDescription"];
            this.justificationAccepted = _data["justificationAccepted"];
            this.decisionDate = _data["decisionDate"] ? new Date(_data["decisionDate"].toString()) : <any>undefined;
            this.cancelledWithDocuments = _data["cancelledWithDocuments"];
            this.programName = _data["programName"];
            this.programTypeId = _data["programTypeId"];
        }
    }

    static fromJS(data: any): SelectOneCommissionInvitationData {
        data = typeof data === 'object' ? data : {};
        let result = new SelectOneCommissionInvitationData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["programId"] = this.programId;
        data["commissionId"] = this.commissionId;
        data["applicationStatusId"] = this.applicationStatusId;
        data["cancelledDate"] = this.cancelledDate ? this.cancelledDate.toISOString() : <any>undefined;
        data["cancelledDescription"] = this.cancelledDescription;
        data["invitationDate"] = this.invitationDate ? this.invitationDate.toISOString() : <any>undefined;
        data["invitationSentUserId"] = this.invitationSentUserId;
        data["userIdIns"] = this.userIdIns;
        data["timeIns"] = this.timeIns ? this.timeIns.toISOString() : <any>undefined;
        data["userIdChg"] = this.userIdChg;
        data["timeChg"] = this.timeChg ? this.timeChg.toISOString() : <any>undefined;
        data["answerDate"] = this.answerDate ? this.answerDate.toISOString() : <any>undefined;
        data["decisionDescription"] = this.decisionDescription;
        data["justificationAccepted"] = this.justificationAccepted;
        data["decisionDate"] = this.decisionDate ? this.decisionDate.toISOString() : <any>undefined;
        data["cancelledWithDocuments"] = this.cancelledWithDocuments;
        data["programName"] = this.programName;
        data["programTypeId"] = this.programTypeId;
        return data;
    }
}

export interface ISelectOneCommissionInvitationData {
    id?: number;
    programId?: number;
    commissionId?: number;
    applicationStatusId?: number;
    cancelledDate?: Date | undefined;
    cancelledDescription?: string | undefined;
    invitationDate?: Date | undefined;
    invitationSentUserId?: number | undefined;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
    answerDate?: Date | undefined;
    decisionDescription?: string | undefined;
    justificationAccepted?: boolean | undefined;
    decisionDate?: Date | undefined;
    cancelledWithDocuments?: boolean | undefined;
    programName?: string | undefined;
    programTypeId?: number;
}

export class SelectOneCommissionInvitationDataUsersResult implements ISelectOneCommissionInvitationDataUsersResult {
    status?: UsersResultStatus;
    content?: SelectOneCommissionInvitationData;

    constructor(data?: ISelectOneCommissionInvitationDataUsersResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.content = _data["content"] ? SelectOneCommissionInvitationData.fromJS(_data["content"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SelectOneCommissionInvitationDataUsersResult {
        data = typeof data === 'object' ? data : {};
        let result = new SelectOneCommissionInvitationDataUsersResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISelectOneCommissionInvitationDataUsersResult {
    status?: UsersResultStatus;
    content?: SelectOneCommissionInvitationData;
}

export class SelectAllExamsData implements ISelectAllExamsData {
    id?: number;
    programId?: number;
    programName?: string | undefined;
    examDate?: Date | undefined;
    examTime?: string | undefined;
    maxTimeInMinutes?: number | undefined;
    examTypeId?: number;
    examTypeName?: string | undefined;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;

    constructor(data?: ISelectAllExamsData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.programId = _data["programId"];
            this.programName = _data["programName"];
            this.examDate = _data["examDate"] ? new Date(_data["examDate"].toString()) : <any>undefined;
            this.examTime = _data["examTime"];
            this.maxTimeInMinutes = _data["maxTimeInMinutes"];
            this.examTypeId = _data["examTypeId"];
            this.examTypeName = _data["examTypeName"];
            this.userIdIns = _data["userIdIns"];
            this.timeIns = _data["timeIns"] ? new Date(_data["timeIns"].toString()) : <any>undefined;
            this.userIdChg = _data["userIdChg"];
            this.timeChg = _data["timeChg"] ? new Date(_data["timeChg"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SelectAllExamsData {
        data = typeof data === 'object' ? data : {};
        let result = new SelectAllExamsData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["programId"] = this.programId;
        data["programName"] = this.programName;
        data["examDate"] = this.examDate ? this.examDate.toISOString() : <any>undefined;
        data["examTime"] = this.examTime;
        data["maxTimeInMinutes"] = this.maxTimeInMinutes;
        data["examTypeId"] = this.examTypeId;
        data["examTypeName"] = this.examTypeName;
        data["userIdIns"] = this.userIdIns;
        data["timeIns"] = this.timeIns ? this.timeIns.toISOString() : <any>undefined;
        data["userIdChg"] = this.userIdChg;
        data["timeChg"] = this.timeChg ? this.timeChg.toISOString() : <any>undefined;
        return data;
    }
}

export interface ISelectAllExamsData {
    id?: number;
    programId?: number;
    programName?: string | undefined;
    examDate?: Date | undefined;
    examTime?: string | undefined;
    maxTimeInMinutes?: number | undefined;
    examTypeId?: number;
    examTypeName?: string | undefined;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
}

export class SelectAllExamsDataPagedModel implements ISelectAllExamsDataPagedModel {
    totalItems?: number;
    items?: SelectAllExamsData[] | undefined;

    constructor(data?: ISelectAllExamsDataPagedModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItems = _data["totalItems"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SelectAllExamsData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SelectAllExamsDataPagedModel {
        data = typeof data === 'object' ? data : {};
        let result = new SelectAllExamsDataPagedModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItems"] = this.totalItems;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISelectAllExamsDataPagedModel {
    totalItems?: number;
    items?: SelectAllExamsData[] | undefined;
}

export class SelectAllExamsDataPagedModelUsersResult implements ISelectAllExamsDataPagedModelUsersResult {
    status?: UsersResultStatus;
    content?: SelectAllExamsDataPagedModel;

    constructor(data?: ISelectAllExamsDataPagedModelUsersResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.content = _data["content"] ? SelectAllExamsDataPagedModel.fromJS(_data["content"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SelectAllExamsDataPagedModelUsersResult {
        data = typeof data === 'object' ? data : {};
        let result = new SelectAllExamsDataPagedModelUsersResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISelectAllExamsDataPagedModelUsersResult {
    status?: UsersResultStatus;
    content?: SelectAllExamsDataPagedModel;
}

export class ExamData implements IExamData {
    id?: number;
    programId?: number;
    examDate?: Date | undefined;
    examTime?: string | undefined;
    maxTimeInMinutes?: number | undefined;
    examTypeId?: number;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;

    constructor(data?: IExamData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.programId = _data["programId"];
            this.examDate = _data["examDate"] ? new Date(_data["examDate"].toString()) : <any>undefined;
            this.examTime = _data["examTime"];
            this.maxTimeInMinutes = _data["maxTimeInMinutes"];
            this.examTypeId = _data["examTypeId"];
            this.userIdIns = _data["userIdIns"];
            this.timeIns = _data["timeIns"] ? new Date(_data["timeIns"].toString()) : <any>undefined;
            this.userIdChg = _data["userIdChg"];
            this.timeChg = _data["timeChg"] ? new Date(_data["timeChg"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ExamData {
        data = typeof data === 'object' ? data : {};
        let result = new ExamData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["programId"] = this.programId;
        data["examDate"] = this.examDate ? this.examDate.toISOString() : <any>undefined;
        data["examTime"] = this.examTime;
        data["maxTimeInMinutes"] = this.maxTimeInMinutes;
        data["examTypeId"] = this.examTypeId;
        data["userIdIns"] = this.userIdIns;
        data["timeIns"] = this.timeIns ? this.timeIns.toISOString() : <any>undefined;
        data["userIdChg"] = this.userIdChg;
        data["timeChg"] = this.timeChg ? this.timeChg.toISOString() : <any>undefined;
        return data;
    }
}

export interface IExamData {
    id?: number;
    programId?: number;
    examDate?: Date | undefined;
    examTime?: string | undefined;
    maxTimeInMinutes?: number | undefined;
    examTypeId?: number;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
}

export class ExamDataUsersResult implements IExamDataUsersResult {
    status?: UsersResultStatus;
    content?: ExamData;

    constructor(data?: IExamDataUsersResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.content = _data["content"] ? ExamData.fromJS(_data["content"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExamDataUsersResult {
        data = typeof data === 'object' ? data : {};
        let result = new ExamDataUsersResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        return data;
    }
}

export interface IExamDataUsersResult {
    status?: UsersResultStatus;
    content?: ExamData;
}

export class SelectAllExamsForParticipantData implements ISelectAllExamsForParticipantData {
    id?: number;
    programId?: number;
    programName?: string | undefined;
    examDate?: Date | undefined;
    examTime?: string | undefined;
    maxTimeInMinutes?: number | undefined;
    examTypeId?: number;
    examTypeName?: string | undefined;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
    participantExamId?: number | undefined;
    justificationAccepted?: boolean | undefined;

    constructor(data?: ISelectAllExamsForParticipantData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.programId = _data["programId"];
            this.programName = _data["programName"];
            this.examDate = _data["examDate"] ? new Date(_data["examDate"].toString()) : <any>undefined;
            this.examTime = _data["examTime"];
            this.maxTimeInMinutes = _data["maxTimeInMinutes"];
            this.examTypeId = _data["examTypeId"];
            this.examTypeName = _data["examTypeName"];
            this.userIdIns = _data["userIdIns"];
            this.timeIns = _data["timeIns"] ? new Date(_data["timeIns"].toString()) : <any>undefined;
            this.userIdChg = _data["userIdChg"];
            this.timeChg = _data["timeChg"] ? new Date(_data["timeChg"].toString()) : <any>undefined;
            this.participantExamId = _data["participantExamId"];
            this.justificationAccepted = _data["justificationAccepted"];
        }
    }

    static fromJS(data: any): SelectAllExamsForParticipantData {
        data = typeof data === 'object' ? data : {};
        let result = new SelectAllExamsForParticipantData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["programId"] = this.programId;
        data["programName"] = this.programName;
        data["examDate"] = this.examDate ? this.examDate.toISOString() : <any>undefined;
        data["examTime"] = this.examTime;
        data["maxTimeInMinutes"] = this.maxTimeInMinutes;
        data["examTypeId"] = this.examTypeId;
        data["examTypeName"] = this.examTypeName;
        data["userIdIns"] = this.userIdIns;
        data["timeIns"] = this.timeIns ? this.timeIns.toISOString() : <any>undefined;
        data["userIdChg"] = this.userIdChg;
        data["timeChg"] = this.timeChg ? this.timeChg.toISOString() : <any>undefined;
        data["participantExamId"] = this.participantExamId;
        data["justificationAccepted"] = this.justificationAccepted;
        return data;
    }
}

export interface ISelectAllExamsForParticipantData {
    id?: number;
    programId?: number;
    programName?: string | undefined;
    examDate?: Date | undefined;
    examTime?: string | undefined;
    maxTimeInMinutes?: number | undefined;
    examTypeId?: number;
    examTypeName?: string | undefined;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
    participantExamId?: number | undefined;
    justificationAccepted?: boolean | undefined;
}

export class SelectAllExamsForParticipantDataPagedModel implements ISelectAllExamsForParticipantDataPagedModel {
    totalItems?: number;
    items?: SelectAllExamsForParticipantData[] | undefined;

    constructor(data?: ISelectAllExamsForParticipantDataPagedModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItems = _data["totalItems"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SelectAllExamsForParticipantData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SelectAllExamsForParticipantDataPagedModel {
        data = typeof data === 'object' ? data : {};
        let result = new SelectAllExamsForParticipantDataPagedModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItems"] = this.totalItems;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISelectAllExamsForParticipantDataPagedModel {
    totalItems?: number;
    items?: SelectAllExamsForParticipantData[] | undefined;
}

export class SelectAllExamsForParticipantDataPagedModelUsersResult implements ISelectAllExamsForParticipantDataPagedModelUsersResult {
    status?: UsersResultStatus;
    content?: SelectAllExamsForParticipantDataPagedModel;

    constructor(data?: ISelectAllExamsForParticipantDataPagedModelUsersResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.content = _data["content"] ? SelectAllExamsForParticipantDataPagedModel.fromJS(_data["content"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SelectAllExamsForParticipantDataPagedModelUsersResult {
        data = typeof data === 'object' ? data : {};
        let result = new SelectAllExamsForParticipantDataPagedModelUsersResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISelectAllExamsForParticipantDataPagedModelUsersResult {
    status?: UsersResultStatus;
    content?: SelectAllExamsForParticipantDataPagedModel;
}

export class SelectAllExamResultsData implements ISelectAllExamResultsData {
    id?: number;
    examId?: number;
    participantId?: number;
    examStart?: Date | undefined;
    examEnd?: Date | undefined;
    scoredPoints?: number | undefined;
    examResultStatusId?: number;
    note?: string | undefined;
    resultMailSent?: boolean;
    certificationMailSent?: boolean;
    ended?: boolean;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
    identificationNumber?: number;
    name?: string | undefined;
    surname?: string | undefined;
    birthdate?: Date | undefined;
    email?: string | undefined;
    userId?: number;
    username?: string | undefined;

    constructor(data?: ISelectAllExamResultsData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.examId = _data["examId"];
            this.participantId = _data["participantId"];
            this.examStart = _data["examStart"] ? new Date(_data["examStart"].toString()) : <any>undefined;
            this.examEnd = _data["examEnd"] ? new Date(_data["examEnd"].toString()) : <any>undefined;
            this.scoredPoints = _data["scoredPoints"];
            this.examResultStatusId = _data["examResultStatusId"];
            this.note = _data["note"];
            this.resultMailSent = _data["resultMailSent"];
            this.certificationMailSent = _data["certificationMailSent"];
            this.ended = _data["ended"];
            this.userIdIns = _data["userIdIns"];
            this.timeIns = _data["timeIns"] ? new Date(_data["timeIns"].toString()) : <any>undefined;
            this.userIdChg = _data["userIdChg"];
            this.timeChg = _data["timeChg"] ? new Date(_data["timeChg"].toString()) : <any>undefined;
            this.identificationNumber = _data["identificationNumber"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.birthdate = _data["birthdate"] ? new Date(_data["birthdate"].toString()) : <any>undefined;
            this.email = _data["email"];
            this.userId = _data["userId"];
            this.username = _data["username"];
        }
    }

    static fromJS(data: any): SelectAllExamResultsData {
        data = typeof data === 'object' ? data : {};
        let result = new SelectAllExamResultsData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["examId"] = this.examId;
        data["participantId"] = this.participantId;
        data["examStart"] = this.examStart ? this.examStart.toISOString() : <any>undefined;
        data["examEnd"] = this.examEnd ? this.examEnd.toISOString() : <any>undefined;
        data["scoredPoints"] = this.scoredPoints;
        data["examResultStatusId"] = this.examResultStatusId;
        data["note"] = this.note;
        data["resultMailSent"] = this.resultMailSent;
        data["certificationMailSent"] = this.certificationMailSent;
        data["ended"] = this.ended;
        data["userIdIns"] = this.userIdIns;
        data["timeIns"] = this.timeIns ? this.timeIns.toISOString() : <any>undefined;
        data["userIdChg"] = this.userIdChg;
        data["timeChg"] = this.timeChg ? this.timeChg.toISOString() : <any>undefined;
        data["identificationNumber"] = this.identificationNumber;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["birthdate"] = this.birthdate ? this.birthdate.toISOString() : <any>undefined;
        data["email"] = this.email;
        data["userId"] = this.userId;
        data["username"] = this.username;
        return data;
    }
}

export interface ISelectAllExamResultsData {
    id?: number;
    examId?: number;
    participantId?: number;
    examStart?: Date | undefined;
    examEnd?: Date | undefined;
    scoredPoints?: number | undefined;
    examResultStatusId?: number;
    note?: string | undefined;
    resultMailSent?: boolean;
    certificationMailSent?: boolean;
    ended?: boolean;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
    identificationNumber?: number;
    name?: string | undefined;
    surname?: string | undefined;
    birthdate?: Date | undefined;
    email?: string | undefined;
    userId?: number;
    username?: string | undefined;
}

export class SelectAllExamResultsDataPagedModel implements ISelectAllExamResultsDataPagedModel {
    totalItems?: number;
    items?: SelectAllExamResultsData[] | undefined;

    constructor(data?: ISelectAllExamResultsDataPagedModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItems = _data["totalItems"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SelectAllExamResultsData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SelectAllExamResultsDataPagedModel {
        data = typeof data === 'object' ? data : {};
        let result = new SelectAllExamResultsDataPagedModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItems"] = this.totalItems;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISelectAllExamResultsDataPagedModel {
    totalItems?: number;
    items?: SelectAllExamResultsData[] | undefined;
}

export class SelectAllExamResultsDataPagedModelUsersResult implements ISelectAllExamResultsDataPagedModelUsersResult {
    status?: UsersResultStatus;
    content?: SelectAllExamResultsDataPagedModel;

    constructor(data?: ISelectAllExamResultsDataPagedModelUsersResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.content = _data["content"] ? SelectAllExamResultsDataPagedModel.fromJS(_data["content"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SelectAllExamResultsDataPagedModelUsersResult {
        data = typeof data === 'object' ? data : {};
        let result = new SelectAllExamResultsDataPagedModelUsersResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISelectAllExamResultsDataPagedModelUsersResult {
    status?: UsersResultStatus;
    content?: SelectAllExamResultsDataPagedModel;
}

export class FillData implements IFillData {
    id?: number;
    name?: string | undefined;

    constructor(data?: IFillData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): FillData {
        data = typeof data === 'object' ? data : {};
        let result = new FillData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IFillData {
    id?: number;
    name?: string | undefined;
}

export class FillDataListUsersResult implements IFillDataListUsersResult {
    status?: UsersResultStatus;
    content?: FillData[] | undefined;

    constructor(data?: IFillDataListUsersResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            if (Array.isArray(_data["content"])) {
                this.content = [] as any;
                for (let item of _data["content"])
                    this.content!.push(FillData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FillDataListUsersResult {
        data = typeof data === 'object' ? data : {};
        let result = new FillDataListUsersResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        if (Array.isArray(this.content)) {
            data["content"] = [];
            for (let item of this.content)
                data["content"].push(item.toJSON());
        }
        return data;
    }
}

export interface IFillDataListUsersResult {
    status?: UsersResultStatus;
    content?: FillData[] | undefined;
}

export class MaterialData implements IMaterialData {
    id?: number;
    trainerInvitationId?: number;
    name?: string | undefined;
    fileName?: string | undefined;
    path?: string | undefined;
    timeIns?: Date;
    userIdIns?: number | undefined;

    constructor(data?: IMaterialData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.trainerInvitationId = _data["trainerInvitationId"];
            this.name = _data["name"];
            this.fileName = _data["fileName"];
            this.path = _data["path"];
            this.timeIns = _data["timeIns"] ? new Date(_data["timeIns"].toString()) : <any>undefined;
            this.userIdIns = _data["userIdIns"];
        }
    }

    static fromJS(data: any): MaterialData {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["trainerInvitationId"] = this.trainerInvitationId;
        data["name"] = this.name;
        data["fileName"] = this.fileName;
        data["path"] = this.path;
        data["timeIns"] = this.timeIns ? this.timeIns.toISOString() : <any>undefined;
        data["userIdIns"] = this.userIdIns;
        return data;
    }
}

export interface IMaterialData {
    id?: number;
    trainerInvitationId?: number;
    name?: string | undefined;
    fileName?: string | undefined;
    path?: string | undefined;
    timeIns?: Date;
    userIdIns?: number | undefined;
}

export class MaterialDataPagedModel implements IMaterialDataPagedModel {
    totalItems?: number;
    items?: MaterialData[] | undefined;

    constructor(data?: IMaterialDataPagedModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItems = _data["totalItems"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MaterialData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MaterialDataPagedModel {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialDataPagedModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItems"] = this.totalItems;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMaterialDataPagedModel {
    totalItems?: number;
    items?: MaterialData[] | undefined;
}

export class MaterialDataPagedModelUsersResult implements IMaterialDataPagedModelUsersResult {
    status?: UsersResultStatus;
    content?: MaterialDataPagedModel;

    constructor(data?: IMaterialDataPagedModelUsersResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.content = _data["content"] ? MaterialDataPagedModel.fromJS(_data["content"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MaterialDataPagedModelUsersResult {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialDataPagedModelUsersResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        return data;
    }
}

export interface IMaterialDataPagedModelUsersResult {
    status?: UsersResultStatus;
    content?: MaterialDataPagedModel;
}

export class InsertIdResultInfo implements IInsertIdResultInfo {
    id?: number;
    statusCode?: DbStatusCode;

    constructor(data?: IInsertIdResultInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.statusCode = _data["statusCode"];
        }
    }

    static fromJS(data: any): InsertIdResultInfo {
        data = typeof data === 'object' ? data : {};
        let result = new InsertIdResultInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["statusCode"] = this.statusCode;
        return data;
    }
}

export interface IInsertIdResultInfo {
    id?: number;
    statusCode?: DbStatusCode;
}

export class SelectAllMaterialsData implements ISelectAllMaterialsData {
    id?: number;
    trainerInvitationId?: number;
    name?: string | undefined;
    fileName?: string | undefined;
    path?: string | undefined;
    timeIns?: Date | undefined;
    userIdIns?: number | undefined;
    trainerName?: string | undefined;
    trainerSurname?: string | undefined;
    dayName?: string | undefined;
    programTypeName?: string | undefined;
    typeId?: number;
    dateAndTime?: Date | undefined;
    applicationStatusId?: number;
    active?: boolean;
    programName?: string | undefined;

    constructor(data?: ISelectAllMaterialsData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.trainerInvitationId = _data["trainerInvitationId"];
            this.name = _data["name"];
            this.fileName = _data["fileName"];
            this.path = _data["path"];
            this.timeIns = _data["timeIns"] ? new Date(_data["timeIns"].toString()) : <any>undefined;
            this.userIdIns = _data["userIdIns"];
            this.trainerName = _data["trainerName"];
            this.trainerSurname = _data["trainerSurname"];
            this.dayName = _data["dayName"];
            this.programTypeName = _data["programTypeName"];
            this.typeId = _data["typeId"];
            this.dateAndTime = _data["dateAndTime"] ? new Date(_data["dateAndTime"].toString()) : <any>undefined;
            this.applicationStatusId = _data["applicationStatusId"];
            this.active = _data["active"];
            this.programName = _data["programName"];
        }
    }

    static fromJS(data: any): SelectAllMaterialsData {
        data = typeof data === 'object' ? data : {};
        let result = new SelectAllMaterialsData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["trainerInvitationId"] = this.trainerInvitationId;
        data["name"] = this.name;
        data["fileName"] = this.fileName;
        data["path"] = this.path;
        data["timeIns"] = this.timeIns ? this.timeIns.toISOString() : <any>undefined;
        data["userIdIns"] = this.userIdIns;
        data["trainerName"] = this.trainerName;
        data["trainerSurname"] = this.trainerSurname;
        data["dayName"] = this.dayName;
        data["programTypeName"] = this.programTypeName;
        data["typeId"] = this.typeId;
        data["dateAndTime"] = this.dateAndTime ? this.dateAndTime.toISOString() : <any>undefined;
        data["applicationStatusId"] = this.applicationStatusId;
        data["active"] = this.active;
        data["programName"] = this.programName;
        return data;
    }
}

export interface ISelectAllMaterialsData {
    id?: number;
    trainerInvitationId?: number;
    name?: string | undefined;
    fileName?: string | undefined;
    path?: string | undefined;
    timeIns?: Date | undefined;
    userIdIns?: number | undefined;
    trainerName?: string | undefined;
    trainerSurname?: string | undefined;
    dayName?: string | undefined;
    programTypeName?: string | undefined;
    typeId?: number;
    dateAndTime?: Date | undefined;
    applicationStatusId?: number;
    active?: boolean;
    programName?: string | undefined;
}

export class SelectAllMaterialsDataPagedModel implements ISelectAllMaterialsDataPagedModel {
    totalItems?: number;
    items?: SelectAllMaterialsData[] | undefined;

    constructor(data?: ISelectAllMaterialsDataPagedModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItems = _data["totalItems"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SelectAllMaterialsData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SelectAllMaterialsDataPagedModel {
        data = typeof data === 'object' ? data : {};
        let result = new SelectAllMaterialsDataPagedModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItems"] = this.totalItems;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISelectAllMaterialsDataPagedModel {
    totalItems?: number;
    items?: SelectAllMaterialsData[] | undefined;
}

export class SelectAllMaterialsDataPagedModelUsersResult implements ISelectAllMaterialsDataPagedModelUsersResult {
    status?: UsersResultStatus;
    content?: SelectAllMaterialsDataPagedModel;

    constructor(data?: ISelectAllMaterialsDataPagedModelUsersResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.content = _data["content"] ? SelectAllMaterialsDataPagedModel.fromJS(_data["content"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SelectAllMaterialsDataPagedModelUsersResult {
        data = typeof data === 'object' ? data : {};
        let result = new SelectAllMaterialsDataPagedModelUsersResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISelectAllMaterialsDataPagedModelUsersResult {
    status?: UsersResultStatus;
    content?: SelectAllMaterialsDataPagedModel;
}

export class SelectAllMessageUsersData implements ISelectAllMessageUsersData {
    id?: number;
    messageTypeId?: number;
    programId?: number | undefined;
    subjectLine?: string | undefined;
    emailBody?: string | undefined;
    timeIns?: Date;
    messageTypeName?: string | undefined;
    programName?: string | undefined;

    constructor(data?: ISelectAllMessageUsersData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.messageTypeId = _data["messageTypeId"];
            this.programId = _data["programId"];
            this.subjectLine = _data["subjectLine"];
            this.emailBody = _data["emailBody"];
            this.timeIns = _data["timeIns"] ? new Date(_data["timeIns"].toString()) : <any>undefined;
            this.messageTypeName = _data["messageTypeName"];
            this.programName = _data["programName"];
        }
    }

    static fromJS(data: any): SelectAllMessageUsersData {
        data = typeof data === 'object' ? data : {};
        let result = new SelectAllMessageUsersData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["messageTypeId"] = this.messageTypeId;
        data["programId"] = this.programId;
        data["subjectLine"] = this.subjectLine;
        data["emailBody"] = this.emailBody;
        data["timeIns"] = this.timeIns ? this.timeIns.toISOString() : <any>undefined;
        data["messageTypeName"] = this.messageTypeName;
        data["programName"] = this.programName;
        return data;
    }
}

export interface ISelectAllMessageUsersData {
    id?: number;
    messageTypeId?: number;
    programId?: number | undefined;
    subjectLine?: string | undefined;
    emailBody?: string | undefined;
    timeIns?: Date;
    messageTypeName?: string | undefined;
    programName?: string | undefined;
}

export class SelectAllMessageUsersDataPagedModel implements ISelectAllMessageUsersDataPagedModel {
    totalItems?: number;
    items?: SelectAllMessageUsersData[] | undefined;

    constructor(data?: ISelectAllMessageUsersDataPagedModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItems = _data["totalItems"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SelectAllMessageUsersData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SelectAllMessageUsersDataPagedModel {
        data = typeof data === 'object' ? data : {};
        let result = new SelectAllMessageUsersDataPagedModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItems"] = this.totalItems;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISelectAllMessageUsersDataPagedModel {
    totalItems?: number;
    items?: SelectAllMessageUsersData[] | undefined;
}

export class SelectAllMessageUsersDataPagedModelUsersResult implements ISelectAllMessageUsersDataPagedModelUsersResult {
    status?: UsersResultStatus;
    content?: SelectAllMessageUsersDataPagedModel;

    constructor(data?: ISelectAllMessageUsersDataPagedModelUsersResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.content = _data["content"] ? SelectAllMessageUsersDataPagedModel.fromJS(_data["content"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SelectAllMessageUsersDataPagedModelUsersResult {
        data = typeof data === 'object' ? data : {};
        let result = new SelectAllMessageUsersDataPagedModelUsersResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISelectAllMessageUsersDataPagedModelUsersResult {
    status?: UsersResultStatus;
    content?: SelectAllMessageUsersDataPagedModel;
}

export class NotificationTotalItemsMessageUser implements INotificationTotalItemsMessageUser {
    totalItemsMessageUser?: number;

    constructor(data?: INotificationTotalItemsMessageUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItemsMessageUser = _data["totalItemsMessageUser"];
        }
    }

    static fromJS(data: any): NotificationTotalItemsMessageUser {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationTotalItemsMessageUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItemsMessageUser"] = this.totalItemsMessageUser;
        return data;
    }
}

export interface INotificationTotalItemsMessageUser {
    totalItemsMessageUser?: number;
}

export class NotificationTotalItemsMessageUserUsersResult implements INotificationTotalItemsMessageUserUsersResult {
    status?: UsersResultStatus;
    content?: NotificationTotalItemsMessageUser;

    constructor(data?: INotificationTotalItemsMessageUserUsersResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.content = _data["content"] ? NotificationTotalItemsMessageUser.fromJS(_data["content"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NotificationTotalItemsMessageUserUsersResult {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationTotalItemsMessageUserUsersResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        return data;
    }
}

export interface INotificationTotalItemsMessageUserUsersResult {
    status?: UsersResultStatus;
    content?: NotificationTotalItemsMessageUser;
}

export class SelectAllParticipantCertificatesData implements ISelectAllParticipantCertificatesData {
    id?: number;
    participantId?: number;
    certificateTypeId?: number;
    certificateTypeName?: string | undefined;
    durationInYears?: number | undefined;
    validFromDate?: Date;
    validToDate?: Date;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
    acquiredDate?: Date;
    providerId?: number;
    providerName?: string | undefined;
    examDate?: Date | undefined;
    examTime?: string | undefined;

    constructor(data?: ISelectAllParticipantCertificatesData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.participantId = _data["participantId"];
            this.certificateTypeId = _data["certificateTypeId"];
            this.certificateTypeName = _data["certificateTypeName"];
            this.durationInYears = _data["durationInYears"];
            this.validFromDate = _data["validFromDate"] ? new Date(_data["validFromDate"].toString()) : <any>undefined;
            this.validToDate = _data["validToDate"] ? new Date(_data["validToDate"].toString()) : <any>undefined;
            this.userIdIns = _data["userIdIns"];
            this.timeIns = _data["timeIns"] ? new Date(_data["timeIns"].toString()) : <any>undefined;
            this.userIdChg = _data["userIdChg"];
            this.timeChg = _data["timeChg"] ? new Date(_data["timeChg"].toString()) : <any>undefined;
            this.acquiredDate = _data["acquiredDate"] ? new Date(_data["acquiredDate"].toString()) : <any>undefined;
            this.providerId = _data["providerId"];
            this.providerName = _data["providerName"];
            this.examDate = _data["examDate"] ? new Date(_data["examDate"].toString()) : <any>undefined;
            this.examTime = _data["examTime"];
        }
    }

    static fromJS(data: any): SelectAllParticipantCertificatesData {
        data = typeof data === 'object' ? data : {};
        let result = new SelectAllParticipantCertificatesData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["participantId"] = this.participantId;
        data["certificateTypeId"] = this.certificateTypeId;
        data["certificateTypeName"] = this.certificateTypeName;
        data["durationInYears"] = this.durationInYears;
        data["validFromDate"] = this.validFromDate ? this.validFromDate.toISOString() : <any>undefined;
        data["validToDate"] = this.validToDate ? this.validToDate.toISOString() : <any>undefined;
        data["userIdIns"] = this.userIdIns;
        data["timeIns"] = this.timeIns ? this.timeIns.toISOString() : <any>undefined;
        data["userIdChg"] = this.userIdChg;
        data["timeChg"] = this.timeChg ? this.timeChg.toISOString() : <any>undefined;
        data["acquiredDate"] = this.acquiredDate ? this.acquiredDate.toISOString() : <any>undefined;
        data["providerId"] = this.providerId;
        data["providerName"] = this.providerName;
        data["examDate"] = this.examDate ? this.examDate.toISOString() : <any>undefined;
        data["examTime"] = this.examTime;
        return data;
    }
}

export interface ISelectAllParticipantCertificatesData {
    id?: number;
    participantId?: number;
    certificateTypeId?: number;
    certificateTypeName?: string | undefined;
    durationInYears?: number | undefined;
    validFromDate?: Date;
    validToDate?: Date;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
    acquiredDate?: Date;
    providerId?: number;
    providerName?: string | undefined;
    examDate?: Date | undefined;
    examTime?: string | undefined;
}

export class SelectAllParticipantCertificatesDataPagedModel implements ISelectAllParticipantCertificatesDataPagedModel {
    totalItems?: number;
    items?: SelectAllParticipantCertificatesData[] | undefined;

    constructor(data?: ISelectAllParticipantCertificatesDataPagedModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItems = _data["totalItems"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SelectAllParticipantCertificatesData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SelectAllParticipantCertificatesDataPagedModel {
        data = typeof data === 'object' ? data : {};
        let result = new SelectAllParticipantCertificatesDataPagedModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItems"] = this.totalItems;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISelectAllParticipantCertificatesDataPagedModel {
    totalItems?: number;
    items?: SelectAllParticipantCertificatesData[] | undefined;
}

export class SelectAllParticipantCertificatesDataPagedModelUsersResult implements ISelectAllParticipantCertificatesDataPagedModelUsersResult {
    status?: UsersResultStatus;
    content?: SelectAllParticipantCertificatesDataPagedModel;

    constructor(data?: ISelectAllParticipantCertificatesDataPagedModelUsersResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.content = _data["content"] ? SelectAllParticipantCertificatesDataPagedModel.fromJS(_data["content"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SelectAllParticipantCertificatesDataPagedModelUsersResult {
        data = typeof data === 'object' ? data : {};
        let result = new SelectAllParticipantCertificatesDataPagedModelUsersResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISelectAllParticipantCertificatesDataPagedModelUsersResult {
    status?: UsersResultStatus;
    content?: SelectAllParticipantCertificatesDataPagedModel;
}

export class SelectAllParticipantCertificatesForRegisterData implements ISelectAllParticipantCertificatesForRegisterData {
    id?: number;
    participantId?: number;
    participantName?: string | undefined;
    participantSurname?: string | undefined;
    institutionName?: string | undefined;
    validFromDate?: Date | undefined;
    validToDate?: Date | undefined;

    constructor(data?: ISelectAllParticipantCertificatesForRegisterData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.participantId = _data["participantId"];
            this.participantName = _data["participantName"];
            this.participantSurname = _data["participantSurname"];
            this.institutionName = _data["institutionName"];
            this.validFromDate = _data["validFromDate"] ? new Date(_data["validFromDate"].toString()) : <any>undefined;
            this.validToDate = _data["validToDate"] ? new Date(_data["validToDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SelectAllParticipantCertificatesForRegisterData {
        data = typeof data === 'object' ? data : {};
        let result = new SelectAllParticipantCertificatesForRegisterData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["participantId"] = this.participantId;
        data["participantName"] = this.participantName;
        data["participantSurname"] = this.participantSurname;
        data["institutionName"] = this.institutionName;
        data["validFromDate"] = this.validFromDate ? this.validFromDate.toISOString() : <any>undefined;
        data["validToDate"] = this.validToDate ? this.validToDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface ISelectAllParticipantCertificatesForRegisterData {
    id?: number;
    participantId?: number;
    participantName?: string | undefined;
    participantSurname?: string | undefined;
    institutionName?: string | undefined;
    validFromDate?: Date | undefined;
    validToDate?: Date | undefined;
}

export class SelectAllParticipantCertificatesForRegisterDataPagedModel implements ISelectAllParticipantCertificatesForRegisterDataPagedModel {
    totalItems?: number;
    items?: SelectAllParticipantCertificatesForRegisterData[] | undefined;

    constructor(data?: ISelectAllParticipantCertificatesForRegisterDataPagedModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItems = _data["totalItems"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SelectAllParticipantCertificatesForRegisterData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SelectAllParticipantCertificatesForRegisterDataPagedModel {
        data = typeof data === 'object' ? data : {};
        let result = new SelectAllParticipantCertificatesForRegisterDataPagedModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItems"] = this.totalItems;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISelectAllParticipantCertificatesForRegisterDataPagedModel {
    totalItems?: number;
    items?: SelectAllParticipantCertificatesForRegisterData[] | undefined;
}

export class SelectAllParticipantCertificatesForRegisterDataPagedModelUsersResult implements ISelectAllParticipantCertificatesForRegisterDataPagedModelUsersResult {
    status?: UsersResultStatus;
    content?: SelectAllParticipantCertificatesForRegisterDataPagedModel;

    constructor(data?: ISelectAllParticipantCertificatesForRegisterDataPagedModelUsersResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.content = _data["content"] ? SelectAllParticipantCertificatesForRegisterDataPagedModel.fromJS(_data["content"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SelectAllParticipantCertificatesForRegisterDataPagedModelUsersResult {
        data = typeof data === 'object' ? data : {};
        let result = new SelectAllParticipantCertificatesForRegisterDataPagedModelUsersResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISelectAllParticipantCertificatesForRegisterDataPagedModelUsersResult {
    status?: UsersResultStatus;
    content?: SelectAllParticipantCertificatesForRegisterDataPagedModel;
}

export class ParticipantExamData implements IParticipantExamData {
    id?: number;
    examId?: number;
    participantId?: number;
    cancelledDate?: Date | undefined;
    cancelledDescription?: string | undefined;
    cancelledWithDocuments?: boolean | undefined;
    justificationAccepted?: boolean | undefined;
    decisionDate?: Date | undefined;
    decisionDescription?: string | undefined;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
    identificationNumber?: number;
    userId?: number;
    name?: string | undefined;
    surname?: string | undefined;
    email?: string | undefined;
    programId?: number;
    programName?: string | undefined;
    examDate?: Date | undefined;
    examTypeId?: number;
    examTypeName?: string | undefined;

    constructor(data?: IParticipantExamData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.examId = _data["examId"];
            this.participantId = _data["participantId"];
            this.cancelledDate = _data["cancelledDate"] ? new Date(_data["cancelledDate"].toString()) : <any>undefined;
            this.cancelledDescription = _data["cancelledDescription"];
            this.cancelledWithDocuments = _data["cancelledWithDocuments"];
            this.justificationAccepted = _data["justificationAccepted"];
            this.decisionDate = _data["decisionDate"] ? new Date(_data["decisionDate"].toString()) : <any>undefined;
            this.decisionDescription = _data["decisionDescription"];
            this.userIdIns = _data["userIdIns"];
            this.timeIns = _data["timeIns"] ? new Date(_data["timeIns"].toString()) : <any>undefined;
            this.userIdChg = _data["userIdChg"];
            this.timeChg = _data["timeChg"] ? new Date(_data["timeChg"].toString()) : <any>undefined;
            this.identificationNumber = _data["identificationNumber"];
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.email = _data["email"];
            this.programId = _data["programId"];
            this.programName = _data["programName"];
            this.examDate = _data["examDate"] ? new Date(_data["examDate"].toString()) : <any>undefined;
            this.examTypeId = _data["examTypeId"];
            this.examTypeName = _data["examTypeName"];
        }
    }

    static fromJS(data: any): ParticipantExamData {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipantExamData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["examId"] = this.examId;
        data["participantId"] = this.participantId;
        data["cancelledDate"] = this.cancelledDate ? this.cancelledDate.toISOString() : <any>undefined;
        data["cancelledDescription"] = this.cancelledDescription;
        data["cancelledWithDocuments"] = this.cancelledWithDocuments;
        data["justificationAccepted"] = this.justificationAccepted;
        data["decisionDate"] = this.decisionDate ? this.decisionDate.toISOString() : <any>undefined;
        data["decisionDescription"] = this.decisionDescription;
        data["userIdIns"] = this.userIdIns;
        data["timeIns"] = this.timeIns ? this.timeIns.toISOString() : <any>undefined;
        data["userIdChg"] = this.userIdChg;
        data["timeChg"] = this.timeChg ? this.timeChg.toISOString() : <any>undefined;
        data["identificationNumber"] = this.identificationNumber;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["email"] = this.email;
        data["programId"] = this.programId;
        data["programName"] = this.programName;
        data["examDate"] = this.examDate ? this.examDate.toISOString() : <any>undefined;
        data["examTypeId"] = this.examTypeId;
        data["examTypeName"] = this.examTypeName;
        return data;
    }
}

export interface IParticipantExamData {
    id?: number;
    examId?: number;
    participantId?: number;
    cancelledDate?: Date | undefined;
    cancelledDescription?: string | undefined;
    cancelledWithDocuments?: boolean | undefined;
    justificationAccepted?: boolean | undefined;
    decisionDate?: Date | undefined;
    decisionDescription?: string | undefined;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
    identificationNumber?: number;
    userId?: number;
    name?: string | undefined;
    surname?: string | undefined;
    email?: string | undefined;
    programId?: number;
    programName?: string | undefined;
    examDate?: Date | undefined;
    examTypeId?: number;
    examTypeName?: string | undefined;
}

export class ParticipantExamDataUsersResult implements IParticipantExamDataUsersResult {
    status?: UsersResultStatus;
    content?: ParticipantExamData;

    constructor(data?: IParticipantExamDataUsersResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.content = _data["content"] ? ParticipantExamData.fromJS(_data["content"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ParticipantExamDataUsersResult {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipantExamDataUsersResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        return data;
    }
}

export interface IParticipantExamDataUsersResult {
    status?: UsersResultStatus;
    content?: ParticipantExamData;
}

export class ParticipantExamAttachmentData implements IParticipantExamAttachmentData {
    id?: number;
    participantExamId?: number;
    name?: string | undefined;
    fileName?: string | undefined;
    path?: string | undefined;
    timeIns?: Date;
    userIdIns?: number | undefined;

    constructor(data?: IParticipantExamAttachmentData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.participantExamId = _data["participantExamId"];
            this.name = _data["name"];
            this.fileName = _data["fileName"];
            this.path = _data["path"];
            this.timeIns = _data["timeIns"] ? new Date(_data["timeIns"].toString()) : <any>undefined;
            this.userIdIns = _data["userIdIns"];
        }
    }

    static fromJS(data: any): ParticipantExamAttachmentData {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipantExamAttachmentData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["participantExamId"] = this.participantExamId;
        data["name"] = this.name;
        data["fileName"] = this.fileName;
        data["path"] = this.path;
        data["timeIns"] = this.timeIns ? this.timeIns.toISOString() : <any>undefined;
        data["userIdIns"] = this.userIdIns;
        return data;
    }
}

export interface IParticipantExamAttachmentData {
    id?: number;
    participantExamId?: number;
    name?: string | undefined;
    fileName?: string | undefined;
    path?: string | undefined;
    timeIns?: Date;
    userIdIns?: number | undefined;
}

export class ParticipantExamAttachmentDataPagedModel implements IParticipantExamAttachmentDataPagedModel {
    totalItems?: number;
    items?: ParticipantExamAttachmentData[] | undefined;

    constructor(data?: IParticipantExamAttachmentDataPagedModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItems = _data["totalItems"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ParticipantExamAttachmentData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ParticipantExamAttachmentDataPagedModel {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipantExamAttachmentDataPagedModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItems"] = this.totalItems;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IParticipantExamAttachmentDataPagedModel {
    totalItems?: number;
    items?: ParticipantExamAttachmentData[] | undefined;
}

export class ParticipantExamAttachmentDataPagedModelUsersResult implements IParticipantExamAttachmentDataPagedModelUsersResult {
    status?: UsersResultStatus;
    content?: ParticipantExamAttachmentDataPagedModel;

    constructor(data?: IParticipantExamAttachmentDataPagedModelUsersResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.content = _data["content"] ? ParticipantExamAttachmentDataPagedModel.fromJS(_data["content"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ParticipantExamAttachmentDataPagedModelUsersResult {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipantExamAttachmentDataPagedModelUsersResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        return data;
    }
}

export interface IParticipantExamAttachmentDataPagedModelUsersResult {
    status?: UsersResultStatus;
    content?: ParticipantExamAttachmentDataPagedModel;
}

export class ParticipantProhibitionData implements IParticipantProhibitionData {
    id?: number;
    participantId?: number;
    validFromDate?: Date;
    validToDate?: Date;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;

    constructor(data?: IParticipantProhibitionData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.participantId = _data["participantId"];
            this.validFromDate = _data["validFromDate"] ? new Date(_data["validFromDate"].toString()) : <any>undefined;
            this.validToDate = _data["validToDate"] ? new Date(_data["validToDate"].toString()) : <any>undefined;
            this.userIdIns = _data["userIdIns"];
            this.timeIns = _data["timeIns"] ? new Date(_data["timeIns"].toString()) : <any>undefined;
            this.userIdChg = _data["userIdChg"];
            this.timeChg = _data["timeChg"] ? new Date(_data["timeChg"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ParticipantProhibitionData {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipantProhibitionData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["participantId"] = this.participantId;
        data["validFromDate"] = this.validFromDate ? this.validFromDate.toISOString() : <any>undefined;
        data["validToDate"] = this.validToDate ? this.validToDate.toISOString() : <any>undefined;
        data["userIdIns"] = this.userIdIns;
        data["timeIns"] = this.timeIns ? this.timeIns.toISOString() : <any>undefined;
        data["userIdChg"] = this.userIdChg;
        data["timeChg"] = this.timeChg ? this.timeChg.toISOString() : <any>undefined;
        return data;
    }
}

export interface IParticipantProhibitionData {
    id?: number;
    participantId?: number;
    validFromDate?: Date;
    validToDate?: Date;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
}

export class ParticipantProhibitionDataUsersResult implements IParticipantProhibitionDataUsersResult {
    status?: UsersResultStatus;
    content?: ParticipantProhibitionData;

    constructor(data?: IParticipantProhibitionDataUsersResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.content = _data["content"] ? ParticipantProhibitionData.fromJS(_data["content"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ParticipantProhibitionDataUsersResult {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipantProhibitionDataUsersResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        return data;
    }
}

export interface IParticipantProhibitionDataUsersResult {
    status?: UsersResultStatus;
    content?: ParticipantProhibitionData;
}

export class PermissionData implements IPermissionData {
    id?: number;
    applicationId?: number;
    permissionCategoryId?: number;
    name?: string | undefined;
    description?: string | undefined;
    active?: boolean;
    isDeleted?: boolean;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
    systemKey?: string | undefined;
    applicationName?: string | undefined;
    categoryName?: string | undefined;
    rolePermissionId?: number | undefined;
    permissionId?: number | undefined;
    roleId?: number | undefined;
    granted?: boolean | undefined;
    rolePermissionActive?: boolean | undefined;
    rolePermissionIsDeleted?: boolean | undefined;
    rolePermissionUserIdIns?: number | undefined;
    rolePermissionTimeIns?: Date | undefined;
    rolePermissionUserIdChg?: number | undefined;
    rolePermissionTimeChg?: Date | undefined;

    constructor(data?: IPermissionData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.applicationId = _data["applicationId"];
            this.permissionCategoryId = _data["permissionCategoryId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.active = _data["active"];
            this.isDeleted = _data["isDeleted"];
            this.userIdIns = _data["userIdIns"];
            this.timeIns = _data["timeIns"] ? new Date(_data["timeIns"].toString()) : <any>undefined;
            this.userIdChg = _data["userIdChg"];
            this.timeChg = _data["timeChg"] ? new Date(_data["timeChg"].toString()) : <any>undefined;
            this.systemKey = _data["systemKey"];
            this.applicationName = _data["applicationName"];
            this.categoryName = _data["categoryName"];
            this.rolePermissionId = _data["rolePermissionId"];
            this.permissionId = _data["permissionId"];
            this.roleId = _data["roleId"];
            this.granted = _data["granted"];
            this.rolePermissionActive = _data["rolePermissionActive"];
            this.rolePermissionIsDeleted = _data["rolePermissionIsDeleted"];
            this.rolePermissionUserIdIns = _data["rolePermissionUserIdIns"];
            this.rolePermissionTimeIns = _data["rolePermissionTimeIns"] ? new Date(_data["rolePermissionTimeIns"].toString()) : <any>undefined;
            this.rolePermissionUserIdChg = _data["rolePermissionUserIdChg"];
            this.rolePermissionTimeChg = _data["rolePermissionTimeChg"] ? new Date(_data["rolePermissionTimeChg"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PermissionData {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["applicationId"] = this.applicationId;
        data["permissionCategoryId"] = this.permissionCategoryId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["active"] = this.active;
        data["isDeleted"] = this.isDeleted;
        data["userIdIns"] = this.userIdIns;
        data["timeIns"] = this.timeIns ? this.timeIns.toISOString() : <any>undefined;
        data["userIdChg"] = this.userIdChg;
        data["timeChg"] = this.timeChg ? this.timeChg.toISOString() : <any>undefined;
        data["systemKey"] = this.systemKey;
        data["applicationName"] = this.applicationName;
        data["categoryName"] = this.categoryName;
        data["rolePermissionId"] = this.rolePermissionId;
        data["permissionId"] = this.permissionId;
        data["roleId"] = this.roleId;
        data["granted"] = this.granted;
        data["rolePermissionActive"] = this.rolePermissionActive;
        data["rolePermissionIsDeleted"] = this.rolePermissionIsDeleted;
        data["rolePermissionUserIdIns"] = this.rolePermissionUserIdIns;
        data["rolePermissionTimeIns"] = this.rolePermissionTimeIns ? this.rolePermissionTimeIns.toISOString() : <any>undefined;
        data["rolePermissionUserIdChg"] = this.rolePermissionUserIdChg;
        data["rolePermissionTimeChg"] = this.rolePermissionTimeChg ? this.rolePermissionTimeChg.toISOString() : <any>undefined;
        return data;
    }
}

export interface IPermissionData {
    id?: number;
    applicationId?: number;
    permissionCategoryId?: number;
    name?: string | undefined;
    description?: string | undefined;
    active?: boolean;
    isDeleted?: boolean;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
    systemKey?: string | undefined;
    applicationName?: string | undefined;
    categoryName?: string | undefined;
    rolePermissionId?: number | undefined;
    permissionId?: number | undefined;
    roleId?: number | undefined;
    granted?: boolean | undefined;
    rolePermissionActive?: boolean | undefined;
    rolePermissionIsDeleted?: boolean | undefined;
    rolePermissionUserIdIns?: number | undefined;
    rolePermissionTimeIns?: Date | undefined;
    rolePermissionUserIdChg?: number | undefined;
    rolePermissionTimeChg?: Date | undefined;
}

export class PermissionDataPagedModel implements IPermissionDataPagedModel {
    totalItems?: number;
    items?: PermissionData[] | undefined;

    constructor(data?: IPermissionDataPagedModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItems = _data["totalItems"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PermissionData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionDataPagedModel {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDataPagedModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItems"] = this.totalItems;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPermissionDataPagedModel {
    totalItems?: number;
    items?: PermissionData[] | undefined;
}

export class PermissionDataPagedModelUsersResult implements IPermissionDataPagedModelUsersResult {
    status?: UsersResultStatus;
    content?: PermissionDataPagedModel;

    constructor(data?: IPermissionDataPagedModelUsersResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.content = _data["content"] ? PermissionDataPagedModel.fromJS(_data["content"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PermissionDataPagedModelUsersResult {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDataPagedModelUsersResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPermissionDataPagedModelUsersResult {
    status?: UsersResultStatus;
    content?: PermissionDataPagedModel;
}

export class PrivacyPolicyData implements IPrivacyPolicyData {
    id?: number;
    dateStart?: Date | undefined;
    dateEnd?: Date | undefined;
    enabled?: boolean;
    policy?: string | undefined;
    docPath?: string | undefined;

    constructor(data?: IPrivacyPolicyData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.dateStart = _data["dateStart"] ? new Date(_data["dateStart"].toString()) : <any>undefined;
            this.dateEnd = _data["dateEnd"] ? new Date(_data["dateEnd"].toString()) : <any>undefined;
            this.enabled = _data["enabled"];
            this.policy = _data["policy"];
            this.docPath = _data["docPath"];
        }
    }

    static fromJS(data: any): PrivacyPolicyData {
        data = typeof data === 'object' ? data : {};
        let result = new PrivacyPolicyData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dateStart"] = this.dateStart ? this.dateStart.toISOString() : <any>undefined;
        data["dateEnd"] = this.dateEnd ? this.dateEnd.toISOString() : <any>undefined;
        data["enabled"] = this.enabled;
        data["policy"] = this.policy;
        data["docPath"] = this.docPath;
        return data;
    }
}

export interface IPrivacyPolicyData {
    id?: number;
    dateStart?: Date | undefined;
    dateEnd?: Date | undefined;
    enabled?: boolean;
    policy?: string | undefined;
    docPath?: string | undefined;
}

export class PrivacyPolicyDataUsersResult implements IPrivacyPolicyDataUsersResult {
    status?: UsersResultStatus;
    content?: PrivacyPolicyData;

    constructor(data?: IPrivacyPolicyDataUsersResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.content = _data["content"] ? PrivacyPolicyData.fromJS(_data["content"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PrivacyPolicyDataUsersResult {
        data = typeof data === 'object' ? data : {};
        let result = new PrivacyPolicyDataUsersResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPrivacyPolicyDataUsersResult {
    status?: UsersResultStatus;
    content?: PrivacyPolicyData;
}

export class SelectAllAppliableProgramsData implements ISelectAllAppliableProgramsData {
    id?: number;
    providerId?: number | undefined;
    trainingProviderName?: string | undefined;
    number?: string | undefined;
    dateOfRegistration?: Date;
    name?: string | undefined;
    typeId?: number;
    programTypeName?: string | undefined;
    programDays?: number;
    programDaysMin?: number;
    price?: number;
    taxRate?: number;
    points?: number;
    participantsMaxNum?: number;
    participantsWaitNum?: number;
    examTime?: string | undefined;
    active?: boolean | undefined;
    description?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    examDate?: Date | undefined;
    examCorrectiveDate?: Date | undefined;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
    applicationStatusId?: number | undefined;
    examStartTime?: string | undefined;
    correctiveExamStartTime?: string | undefined;

    constructor(data?: ISelectAllAppliableProgramsData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.providerId = _data["providerId"];
            this.trainingProviderName = _data["trainingProviderName"];
            this.number = _data["number"];
            this.dateOfRegistration = _data["dateOfRegistration"] ? new Date(_data["dateOfRegistration"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.typeId = _data["typeId"];
            this.programTypeName = _data["programTypeName"];
            this.programDays = _data["programDays"];
            this.programDaysMin = _data["programDaysMin"];
            this.price = _data["price"];
            this.taxRate = _data["taxRate"];
            this.points = _data["points"];
            this.participantsMaxNum = _data["participantsMaxNum"];
            this.participantsWaitNum = _data["participantsWaitNum"];
            this.examTime = _data["examTime"];
            this.active = _data["active"];
            this.description = _data["description"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.examDate = _data["examDate"] ? new Date(_data["examDate"].toString()) : <any>undefined;
            this.examCorrectiveDate = _data["examCorrectiveDate"] ? new Date(_data["examCorrectiveDate"].toString()) : <any>undefined;
            this.userIdIns = _data["userIdIns"];
            this.timeIns = _data["timeIns"] ? new Date(_data["timeIns"].toString()) : <any>undefined;
            this.userIdChg = _data["userIdChg"];
            this.timeChg = _data["timeChg"] ? new Date(_data["timeChg"].toString()) : <any>undefined;
            this.applicationStatusId = _data["applicationStatusId"];
            this.examStartTime = _data["examStartTime"];
            this.correctiveExamStartTime = _data["correctiveExamStartTime"];
        }
    }

    static fromJS(data: any): SelectAllAppliableProgramsData {
        data = typeof data === 'object' ? data : {};
        let result = new SelectAllAppliableProgramsData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["providerId"] = this.providerId;
        data["trainingProviderName"] = this.trainingProviderName;
        data["number"] = this.number;
        data["dateOfRegistration"] = this.dateOfRegistration ? this.dateOfRegistration.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["typeId"] = this.typeId;
        data["programTypeName"] = this.programTypeName;
        data["programDays"] = this.programDays;
        data["programDaysMin"] = this.programDaysMin;
        data["price"] = this.price;
        data["taxRate"] = this.taxRate;
        data["points"] = this.points;
        data["participantsMaxNum"] = this.participantsMaxNum;
        data["participantsWaitNum"] = this.participantsWaitNum;
        data["examTime"] = this.examTime;
        data["active"] = this.active;
        data["description"] = this.description;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["examDate"] = this.examDate ? this.examDate.toISOString() : <any>undefined;
        data["examCorrectiveDate"] = this.examCorrectiveDate ? this.examCorrectiveDate.toISOString() : <any>undefined;
        data["userIdIns"] = this.userIdIns;
        data["timeIns"] = this.timeIns ? this.timeIns.toISOString() : <any>undefined;
        data["userIdChg"] = this.userIdChg;
        data["timeChg"] = this.timeChg ? this.timeChg.toISOString() : <any>undefined;
        data["applicationStatusId"] = this.applicationStatusId;
        data["examStartTime"] = this.examStartTime;
        data["correctiveExamStartTime"] = this.correctiveExamStartTime;
        return data;
    }
}

export interface ISelectAllAppliableProgramsData {
    id?: number;
    providerId?: number | undefined;
    trainingProviderName?: string | undefined;
    number?: string | undefined;
    dateOfRegistration?: Date;
    name?: string | undefined;
    typeId?: number;
    programTypeName?: string | undefined;
    programDays?: number;
    programDaysMin?: number;
    price?: number;
    taxRate?: number;
    points?: number;
    participantsMaxNum?: number;
    participantsWaitNum?: number;
    examTime?: string | undefined;
    active?: boolean | undefined;
    description?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    examDate?: Date | undefined;
    examCorrectiveDate?: Date | undefined;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
    applicationStatusId?: number | undefined;
    examStartTime?: string | undefined;
    correctiveExamStartTime?: string | undefined;
}

export class SelectAllAppliableProgramsDataPagedModel implements ISelectAllAppliableProgramsDataPagedModel {
    totalItems?: number;
    items?: SelectAllAppliableProgramsData[] | undefined;

    constructor(data?: ISelectAllAppliableProgramsDataPagedModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItems = _data["totalItems"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SelectAllAppliableProgramsData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SelectAllAppliableProgramsDataPagedModel {
        data = typeof data === 'object' ? data : {};
        let result = new SelectAllAppliableProgramsDataPagedModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItems"] = this.totalItems;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISelectAllAppliableProgramsDataPagedModel {
    totalItems?: number;
    items?: SelectAllAppliableProgramsData[] | undefined;
}

export class SelectAllAppliableProgramsDataPagedModelUsersResult implements ISelectAllAppliableProgramsDataPagedModelUsersResult {
    status?: UsersResultStatus;
    content?: SelectAllAppliableProgramsDataPagedModel;

    constructor(data?: ISelectAllAppliableProgramsDataPagedModelUsersResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.content = _data["content"] ? SelectAllAppliableProgramsDataPagedModel.fromJS(_data["content"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SelectAllAppliableProgramsDataPagedModelUsersResult {
        data = typeof data === 'object' ? data : {};
        let result = new SelectAllAppliableProgramsDataPagedModelUsersResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISelectAllAppliableProgramsDataPagedModelUsersResult {
    status?: UsersResultStatus;
    content?: SelectAllAppliableProgramsDataPagedModel;
}

export class SelectAllActiveProgramsData implements ISelectAllActiveProgramsData {
    id?: number;
    providerId?: number | undefined;
    trainingProviderName?: string | undefined;
    number?: string | undefined;
    dateOfRegistration?: Date;
    name?: string | undefined;
    typeId?: number;
    programTypeName?: string | undefined;
    programDays?: number;
    programDaysMin?: number;
    price?: number;
    taxRate?: number;
    points?: number;
    participantsMaxNum?: number;
    participantsWaitNum?: number;
    examTime?: string | undefined;
    active?: boolean | undefined;
    description?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    examDate?: Date | undefined;
    examCorrectiveDate?: Date | undefined;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
    programQuestionnaireId?: number | undefined;
    programSurveyId?: number | undefined;
    examStartTime?: string | undefined;
    correctiveExamStartTime?: string | undefined;

    constructor(data?: ISelectAllActiveProgramsData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.providerId = _data["providerId"];
            this.trainingProviderName = _data["trainingProviderName"];
            this.number = _data["number"];
            this.dateOfRegistration = _data["dateOfRegistration"] ? new Date(_data["dateOfRegistration"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.typeId = _data["typeId"];
            this.programTypeName = _data["programTypeName"];
            this.programDays = _data["programDays"];
            this.programDaysMin = _data["programDaysMin"];
            this.price = _data["price"];
            this.taxRate = _data["taxRate"];
            this.points = _data["points"];
            this.participantsMaxNum = _data["participantsMaxNum"];
            this.participantsWaitNum = _data["participantsWaitNum"];
            this.examTime = _data["examTime"];
            this.active = _data["active"];
            this.description = _data["description"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.examDate = _data["examDate"] ? new Date(_data["examDate"].toString()) : <any>undefined;
            this.examCorrectiveDate = _data["examCorrectiveDate"] ? new Date(_data["examCorrectiveDate"].toString()) : <any>undefined;
            this.userIdIns = _data["userIdIns"];
            this.timeIns = _data["timeIns"] ? new Date(_data["timeIns"].toString()) : <any>undefined;
            this.userIdChg = _data["userIdChg"];
            this.timeChg = _data["timeChg"] ? new Date(_data["timeChg"].toString()) : <any>undefined;
            this.programQuestionnaireId = _data["programQuestionnaireId"];
            this.programSurveyId = _data["programSurveyId"];
            this.examStartTime = _data["examStartTime"];
            this.correctiveExamStartTime = _data["correctiveExamStartTime"];
        }
    }

    static fromJS(data: any): SelectAllActiveProgramsData {
        data = typeof data === 'object' ? data : {};
        let result = new SelectAllActiveProgramsData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["providerId"] = this.providerId;
        data["trainingProviderName"] = this.trainingProviderName;
        data["number"] = this.number;
        data["dateOfRegistration"] = this.dateOfRegistration ? this.dateOfRegistration.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["typeId"] = this.typeId;
        data["programTypeName"] = this.programTypeName;
        data["programDays"] = this.programDays;
        data["programDaysMin"] = this.programDaysMin;
        data["price"] = this.price;
        data["taxRate"] = this.taxRate;
        data["points"] = this.points;
        data["participantsMaxNum"] = this.participantsMaxNum;
        data["participantsWaitNum"] = this.participantsWaitNum;
        data["examTime"] = this.examTime;
        data["active"] = this.active;
        data["description"] = this.description;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["examDate"] = this.examDate ? this.examDate.toISOString() : <any>undefined;
        data["examCorrectiveDate"] = this.examCorrectiveDate ? this.examCorrectiveDate.toISOString() : <any>undefined;
        data["userIdIns"] = this.userIdIns;
        data["timeIns"] = this.timeIns ? this.timeIns.toISOString() : <any>undefined;
        data["userIdChg"] = this.userIdChg;
        data["timeChg"] = this.timeChg ? this.timeChg.toISOString() : <any>undefined;
        data["programQuestionnaireId"] = this.programQuestionnaireId;
        data["programSurveyId"] = this.programSurveyId;
        data["examStartTime"] = this.examStartTime;
        data["correctiveExamStartTime"] = this.correctiveExamStartTime;
        return data;
    }
}

export interface ISelectAllActiveProgramsData {
    id?: number;
    providerId?: number | undefined;
    trainingProviderName?: string | undefined;
    number?: string | undefined;
    dateOfRegistration?: Date;
    name?: string | undefined;
    typeId?: number;
    programTypeName?: string | undefined;
    programDays?: number;
    programDaysMin?: number;
    price?: number;
    taxRate?: number;
    points?: number;
    participantsMaxNum?: number;
    participantsWaitNum?: number;
    examTime?: string | undefined;
    active?: boolean | undefined;
    description?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    examDate?: Date | undefined;
    examCorrectiveDate?: Date | undefined;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
    programQuestionnaireId?: number | undefined;
    programSurveyId?: number | undefined;
    examStartTime?: string | undefined;
    correctiveExamStartTime?: string | undefined;
}

export class SelectAllActiveProgramsDataPagedModel implements ISelectAllActiveProgramsDataPagedModel {
    totalItems?: number;
    items?: SelectAllActiveProgramsData[] | undefined;

    constructor(data?: ISelectAllActiveProgramsDataPagedModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItems = _data["totalItems"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SelectAllActiveProgramsData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SelectAllActiveProgramsDataPagedModel {
        data = typeof data === 'object' ? data : {};
        let result = new SelectAllActiveProgramsDataPagedModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItems"] = this.totalItems;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISelectAllActiveProgramsDataPagedModel {
    totalItems?: number;
    items?: SelectAllActiveProgramsData[] | undefined;
}

export class SelectAllActiveProgramsDataPagedModelUsersResult implements ISelectAllActiveProgramsDataPagedModelUsersResult {
    status?: UsersResultStatus;
    content?: SelectAllActiveProgramsDataPagedModel;

    constructor(data?: ISelectAllActiveProgramsDataPagedModelUsersResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.content = _data["content"] ? SelectAllActiveProgramsDataPagedModel.fromJS(_data["content"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SelectAllActiveProgramsDataPagedModelUsersResult {
        data = typeof data === 'object' ? data : {};
        let result = new SelectAllActiveProgramsDataPagedModelUsersResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISelectAllActiveProgramsDataPagedModelUsersResult {
    status?: UsersResultStatus;
    content?: SelectAllActiveProgramsDataPagedModel;
}

export class SelectAllOnHoldProgramsData implements ISelectAllOnHoldProgramsData {
    id?: number;
    providerId?: number | undefined;
    trainingProviderName?: string | undefined;
    number?: string | undefined;
    dateOfRegistration?: Date;
    name?: string | undefined;
    typeId?: number;
    programTypeName?: string | undefined;
    programDays?: number;
    programDaysMin?: number;
    price?: number;
    taxRate?: number;
    points?: number;
    participantsMaxNum?: number;
    participantsWaitNum?: number;
    examTime?: string | undefined;
    active?: boolean | undefined;
    description?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    examDate?: Date | undefined;
    examCorrectiveDate?: Date | undefined;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
    waitingListPosition?: number;
    examStartTime?: string | undefined;
    correctiveExamStartTime?: string | undefined;

    constructor(data?: ISelectAllOnHoldProgramsData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.providerId = _data["providerId"];
            this.trainingProviderName = _data["trainingProviderName"];
            this.number = _data["number"];
            this.dateOfRegistration = _data["dateOfRegistration"] ? new Date(_data["dateOfRegistration"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.typeId = _data["typeId"];
            this.programTypeName = _data["programTypeName"];
            this.programDays = _data["programDays"];
            this.programDaysMin = _data["programDaysMin"];
            this.price = _data["price"];
            this.taxRate = _data["taxRate"];
            this.points = _data["points"];
            this.participantsMaxNum = _data["participantsMaxNum"];
            this.participantsWaitNum = _data["participantsWaitNum"];
            this.examTime = _data["examTime"];
            this.active = _data["active"];
            this.description = _data["description"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.examDate = _data["examDate"] ? new Date(_data["examDate"].toString()) : <any>undefined;
            this.examCorrectiveDate = _data["examCorrectiveDate"] ? new Date(_data["examCorrectiveDate"].toString()) : <any>undefined;
            this.userIdIns = _data["userIdIns"];
            this.timeIns = _data["timeIns"] ? new Date(_data["timeIns"].toString()) : <any>undefined;
            this.userIdChg = _data["userIdChg"];
            this.timeChg = _data["timeChg"] ? new Date(_data["timeChg"].toString()) : <any>undefined;
            this.waitingListPosition = _data["waitingListPosition"];
            this.examStartTime = _data["examStartTime"];
            this.correctiveExamStartTime = _data["correctiveExamStartTime"];
        }
    }

    static fromJS(data: any): SelectAllOnHoldProgramsData {
        data = typeof data === 'object' ? data : {};
        let result = new SelectAllOnHoldProgramsData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["providerId"] = this.providerId;
        data["trainingProviderName"] = this.trainingProviderName;
        data["number"] = this.number;
        data["dateOfRegistration"] = this.dateOfRegistration ? this.dateOfRegistration.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["typeId"] = this.typeId;
        data["programTypeName"] = this.programTypeName;
        data["programDays"] = this.programDays;
        data["programDaysMin"] = this.programDaysMin;
        data["price"] = this.price;
        data["taxRate"] = this.taxRate;
        data["points"] = this.points;
        data["participantsMaxNum"] = this.participantsMaxNum;
        data["participantsWaitNum"] = this.participantsWaitNum;
        data["examTime"] = this.examTime;
        data["active"] = this.active;
        data["description"] = this.description;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["examDate"] = this.examDate ? this.examDate.toISOString() : <any>undefined;
        data["examCorrectiveDate"] = this.examCorrectiveDate ? this.examCorrectiveDate.toISOString() : <any>undefined;
        data["userIdIns"] = this.userIdIns;
        data["timeIns"] = this.timeIns ? this.timeIns.toISOString() : <any>undefined;
        data["userIdChg"] = this.userIdChg;
        data["timeChg"] = this.timeChg ? this.timeChg.toISOString() : <any>undefined;
        data["waitingListPosition"] = this.waitingListPosition;
        data["examStartTime"] = this.examStartTime;
        data["correctiveExamStartTime"] = this.correctiveExamStartTime;
        return data;
    }
}

export interface ISelectAllOnHoldProgramsData {
    id?: number;
    providerId?: number | undefined;
    trainingProviderName?: string | undefined;
    number?: string | undefined;
    dateOfRegistration?: Date;
    name?: string | undefined;
    typeId?: number;
    programTypeName?: string | undefined;
    programDays?: number;
    programDaysMin?: number;
    price?: number;
    taxRate?: number;
    points?: number;
    participantsMaxNum?: number;
    participantsWaitNum?: number;
    examTime?: string | undefined;
    active?: boolean | undefined;
    description?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    examDate?: Date | undefined;
    examCorrectiveDate?: Date | undefined;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
    waitingListPosition?: number;
    examStartTime?: string | undefined;
    correctiveExamStartTime?: string | undefined;
}

export class SelectAllOnHoldProgramsDataPagedModel implements ISelectAllOnHoldProgramsDataPagedModel {
    totalItems?: number;
    items?: SelectAllOnHoldProgramsData[] | undefined;

    constructor(data?: ISelectAllOnHoldProgramsDataPagedModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItems = _data["totalItems"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SelectAllOnHoldProgramsData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SelectAllOnHoldProgramsDataPagedModel {
        data = typeof data === 'object' ? data : {};
        let result = new SelectAllOnHoldProgramsDataPagedModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItems"] = this.totalItems;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISelectAllOnHoldProgramsDataPagedModel {
    totalItems?: number;
    items?: SelectAllOnHoldProgramsData[] | undefined;
}

export class SelectAllOnHoldProgramsDataPagedModelUsersResult implements ISelectAllOnHoldProgramsDataPagedModelUsersResult {
    status?: UsersResultStatus;
    content?: SelectAllOnHoldProgramsDataPagedModel;

    constructor(data?: ISelectAllOnHoldProgramsDataPagedModelUsersResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.content = _data["content"] ? SelectAllOnHoldProgramsDataPagedModel.fromJS(_data["content"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SelectAllOnHoldProgramsDataPagedModelUsersResult {
        data = typeof data === 'object' ? data : {};
        let result = new SelectAllOnHoldProgramsDataPagedModelUsersResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISelectAllOnHoldProgramsDataPagedModelUsersResult {
    status?: UsersResultStatus;
    content?: SelectAllOnHoldProgramsDataPagedModel;
}

export class SelectAllCompletedProgramsData implements ISelectAllCompletedProgramsData {
    id?: number;
    providerId?: number | undefined;
    trainingProviderName?: string | undefined;
    number?: string | undefined;
    dateOfRegistration?: Date;
    name?: string | undefined;
    typeId?: number;
    programTypeName?: string | undefined;
    programDays?: number;
    programDaysMin?: number;
    price?: number;
    taxRate?: number;
    points?: number;
    participantsMaxNum?: number;
    participantsWaitNum?: number;
    examTime?: string | undefined;
    active?: boolean | undefined;
    description?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    examDate?: Date | undefined;
    examCorrectiveDate?: Date | undefined;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
    applicationStatusId?: number | undefined;
    examResultId?: number | undefined;
    examStart?: Date | undefined;
    examEnd?: Date | undefined;
    scoredPoints?: number | undefined;
    examResultStatusId?: number | undefined;
    ended?: boolean | undefined;

    constructor(data?: ISelectAllCompletedProgramsData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.providerId = _data["providerId"];
            this.trainingProviderName = _data["trainingProviderName"];
            this.number = _data["number"];
            this.dateOfRegistration = _data["dateOfRegistration"] ? new Date(_data["dateOfRegistration"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.typeId = _data["typeId"];
            this.programTypeName = _data["programTypeName"];
            this.programDays = _data["programDays"];
            this.programDaysMin = _data["programDaysMin"];
            this.price = _data["price"];
            this.taxRate = _data["taxRate"];
            this.points = _data["points"];
            this.participantsMaxNum = _data["participantsMaxNum"];
            this.participantsWaitNum = _data["participantsWaitNum"];
            this.examTime = _data["examTime"];
            this.active = _data["active"];
            this.description = _data["description"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.examDate = _data["examDate"] ? new Date(_data["examDate"].toString()) : <any>undefined;
            this.examCorrectiveDate = _data["examCorrectiveDate"] ? new Date(_data["examCorrectiveDate"].toString()) : <any>undefined;
            this.userIdIns = _data["userIdIns"];
            this.timeIns = _data["timeIns"] ? new Date(_data["timeIns"].toString()) : <any>undefined;
            this.userIdChg = _data["userIdChg"];
            this.timeChg = _data["timeChg"] ? new Date(_data["timeChg"].toString()) : <any>undefined;
            this.applicationStatusId = _data["applicationStatusId"];
            this.examResultId = _data["examResultId"];
            this.examStart = _data["examStart"] ? new Date(_data["examStart"].toString()) : <any>undefined;
            this.examEnd = _data["examEnd"] ? new Date(_data["examEnd"].toString()) : <any>undefined;
            this.scoredPoints = _data["scoredPoints"];
            this.examResultStatusId = _data["examResultStatusId"];
            this.ended = _data["ended"];
        }
    }

    static fromJS(data: any): SelectAllCompletedProgramsData {
        data = typeof data === 'object' ? data : {};
        let result = new SelectAllCompletedProgramsData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["providerId"] = this.providerId;
        data["trainingProviderName"] = this.trainingProviderName;
        data["number"] = this.number;
        data["dateOfRegistration"] = this.dateOfRegistration ? this.dateOfRegistration.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["typeId"] = this.typeId;
        data["programTypeName"] = this.programTypeName;
        data["programDays"] = this.programDays;
        data["programDaysMin"] = this.programDaysMin;
        data["price"] = this.price;
        data["taxRate"] = this.taxRate;
        data["points"] = this.points;
        data["participantsMaxNum"] = this.participantsMaxNum;
        data["participantsWaitNum"] = this.participantsWaitNum;
        data["examTime"] = this.examTime;
        data["active"] = this.active;
        data["description"] = this.description;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["examDate"] = this.examDate ? this.examDate.toISOString() : <any>undefined;
        data["examCorrectiveDate"] = this.examCorrectiveDate ? this.examCorrectiveDate.toISOString() : <any>undefined;
        data["userIdIns"] = this.userIdIns;
        data["timeIns"] = this.timeIns ? this.timeIns.toISOString() : <any>undefined;
        data["userIdChg"] = this.userIdChg;
        data["timeChg"] = this.timeChg ? this.timeChg.toISOString() : <any>undefined;
        data["applicationStatusId"] = this.applicationStatusId;
        data["examResultId"] = this.examResultId;
        data["examStart"] = this.examStart ? this.examStart.toISOString() : <any>undefined;
        data["examEnd"] = this.examEnd ? this.examEnd.toISOString() : <any>undefined;
        data["scoredPoints"] = this.scoredPoints;
        data["examResultStatusId"] = this.examResultStatusId;
        data["ended"] = this.ended;
        return data;
    }
}

export interface ISelectAllCompletedProgramsData {
    id?: number;
    providerId?: number | undefined;
    trainingProviderName?: string | undefined;
    number?: string | undefined;
    dateOfRegistration?: Date;
    name?: string | undefined;
    typeId?: number;
    programTypeName?: string | undefined;
    programDays?: number;
    programDaysMin?: number;
    price?: number;
    taxRate?: number;
    points?: number;
    participantsMaxNum?: number;
    participantsWaitNum?: number;
    examTime?: string | undefined;
    active?: boolean | undefined;
    description?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    examDate?: Date | undefined;
    examCorrectiveDate?: Date | undefined;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
    applicationStatusId?: number | undefined;
    examResultId?: number | undefined;
    examStart?: Date | undefined;
    examEnd?: Date | undefined;
    scoredPoints?: number | undefined;
    examResultStatusId?: number | undefined;
    ended?: boolean | undefined;
}

export class SelectAllCompletedProgramsDataPagedModel implements ISelectAllCompletedProgramsDataPagedModel {
    totalItems?: number;
    items?: SelectAllCompletedProgramsData[] | undefined;

    constructor(data?: ISelectAllCompletedProgramsDataPagedModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItems = _data["totalItems"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SelectAllCompletedProgramsData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SelectAllCompletedProgramsDataPagedModel {
        data = typeof data === 'object' ? data : {};
        let result = new SelectAllCompletedProgramsDataPagedModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItems"] = this.totalItems;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISelectAllCompletedProgramsDataPagedModel {
    totalItems?: number;
    items?: SelectAllCompletedProgramsData[] | undefined;
}

export class SelectAllCompletedProgramsDataPagedModelUsersResult implements ISelectAllCompletedProgramsDataPagedModelUsersResult {
    status?: UsersResultStatus;
    content?: SelectAllCompletedProgramsDataPagedModel;

    constructor(data?: ISelectAllCompletedProgramsDataPagedModelUsersResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.content = _data["content"] ? SelectAllCompletedProgramsDataPagedModel.fromJS(_data["content"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SelectAllCompletedProgramsDataPagedModelUsersResult {
        data = typeof data === 'object' ? data : {};
        let result = new SelectAllCompletedProgramsDataPagedModelUsersResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISelectAllCompletedProgramsDataPagedModelUsersResult {
    status?: UsersResultStatus;
    content?: SelectAllCompletedProgramsDataPagedModel;
}

export class SelectOneAppliableProgramData implements ISelectOneAppliableProgramData {
    id?: number;
    name?: string | undefined;
    programTypeName?: string | undefined;
    trainingProviderName?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    examDate?: Date | undefined;
    examCorrectiveDate?: Date | undefined;
    freePlacesForApplying?: number;
    freePlacesForWaitList?: number;
    participantsMinNum?: number;
    teachingHours?: number;

    constructor(data?: ISelectOneAppliableProgramData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.programTypeName = _data["programTypeName"];
            this.trainingProviderName = _data["trainingProviderName"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.examDate = _data["examDate"] ? new Date(_data["examDate"].toString()) : <any>undefined;
            this.examCorrectiveDate = _data["examCorrectiveDate"] ? new Date(_data["examCorrectiveDate"].toString()) : <any>undefined;
            this.freePlacesForApplying = _data["freePlacesForApplying"];
            this.freePlacesForWaitList = _data["freePlacesForWaitList"];
            this.participantsMinNum = _data["participantsMinNum"];
            this.teachingHours = _data["teachingHours"];
        }
    }

    static fromJS(data: any): SelectOneAppliableProgramData {
        data = typeof data === 'object' ? data : {};
        let result = new SelectOneAppliableProgramData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["programTypeName"] = this.programTypeName;
        data["trainingProviderName"] = this.trainingProviderName;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["examDate"] = this.examDate ? this.examDate.toISOString() : <any>undefined;
        data["examCorrectiveDate"] = this.examCorrectiveDate ? this.examCorrectiveDate.toISOString() : <any>undefined;
        data["freePlacesForApplying"] = this.freePlacesForApplying;
        data["freePlacesForWaitList"] = this.freePlacesForWaitList;
        data["participantsMinNum"] = this.participantsMinNum;
        data["teachingHours"] = this.teachingHours;
        return data;
    }
}

export interface ISelectOneAppliableProgramData {
    id?: number;
    name?: string | undefined;
    programTypeName?: string | undefined;
    trainingProviderName?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    examDate?: Date | undefined;
    examCorrectiveDate?: Date | undefined;
    freePlacesForApplying?: number;
    freePlacesForWaitList?: number;
    participantsMinNum?: number;
    teachingHours?: number;
}

export class SelectOneAppliableProgramDataUsersResult implements ISelectOneAppliableProgramDataUsersResult {
    status?: UsersResultStatus;
    content?: SelectOneAppliableProgramData;

    constructor(data?: ISelectOneAppliableProgramDataUsersResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.content = _data["content"] ? SelectOneAppliableProgramData.fromJS(_data["content"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SelectOneAppliableProgramDataUsersResult {
        data = typeof data === 'object' ? data : {};
        let result = new SelectOneAppliableProgramDataUsersResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISelectOneAppliableProgramDataUsersResult {
    status?: UsersResultStatus;
    content?: SelectOneAppliableProgramData;
}

export class InsertProgramApplicationRequestData implements IInsertProgramApplicationRequestData {
    programId?: number;
    programName?: string | undefined;

    constructor(data?: IInsertProgramApplicationRequestData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.programId = _data["programId"];
            this.programName = _data["programName"];
        }
    }

    static fromJS(data: any): InsertProgramApplicationRequestData {
        data = typeof data === 'object' ? data : {};
        let result = new InsertProgramApplicationRequestData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["programId"] = this.programId;
        data["programName"] = this.programName;
        return data;
    }
}

export interface IInsertProgramApplicationRequestData {
    programId?: number;
    programName?: string | undefined;
}

export class SelectOneProgramApplicationData implements ISelectOneProgramApplicationData {
    id?: number;
    programId?: number;
    participantId?: number;
    applicationDate?: Date | undefined;
    applicationStatusId?: number;
    cancelledDate?: Date | undefined;
    cancelledDescription?: string | undefined;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
    invitationDate?: Date | undefined;
    invitationSentUserId?: number | undefined;
    justificationAccepted?: boolean | undefined;
    decisionDate?: Date | undefined;
    decisionDescription?: string | undefined;
    cancelledWithDocuments?: boolean | undefined;

    constructor(data?: ISelectOneProgramApplicationData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.programId = _data["programId"];
            this.participantId = _data["participantId"];
            this.applicationDate = _data["applicationDate"] ? new Date(_data["applicationDate"].toString()) : <any>undefined;
            this.applicationStatusId = _data["applicationStatusId"];
            this.cancelledDate = _data["cancelledDate"] ? new Date(_data["cancelledDate"].toString()) : <any>undefined;
            this.cancelledDescription = _data["cancelledDescription"];
            this.userIdIns = _data["userIdIns"];
            this.timeIns = _data["timeIns"] ? new Date(_data["timeIns"].toString()) : <any>undefined;
            this.userIdChg = _data["userIdChg"];
            this.timeChg = _data["timeChg"] ? new Date(_data["timeChg"].toString()) : <any>undefined;
            this.invitationDate = _data["invitationDate"] ? new Date(_data["invitationDate"].toString()) : <any>undefined;
            this.invitationSentUserId = _data["invitationSentUserId"];
            this.justificationAccepted = _data["justificationAccepted"];
            this.decisionDate = _data["decisionDate"] ? new Date(_data["decisionDate"].toString()) : <any>undefined;
            this.decisionDescription = _data["decisionDescription"];
            this.cancelledWithDocuments = _data["cancelledWithDocuments"];
        }
    }

    static fromJS(data: any): SelectOneProgramApplicationData {
        data = typeof data === 'object' ? data : {};
        let result = new SelectOneProgramApplicationData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["programId"] = this.programId;
        data["participantId"] = this.participantId;
        data["applicationDate"] = this.applicationDate ? this.applicationDate.toISOString() : <any>undefined;
        data["applicationStatusId"] = this.applicationStatusId;
        data["cancelledDate"] = this.cancelledDate ? this.cancelledDate.toISOString() : <any>undefined;
        data["cancelledDescription"] = this.cancelledDescription;
        data["userIdIns"] = this.userIdIns;
        data["timeIns"] = this.timeIns ? this.timeIns.toISOString() : <any>undefined;
        data["userIdChg"] = this.userIdChg;
        data["timeChg"] = this.timeChg ? this.timeChg.toISOString() : <any>undefined;
        data["invitationDate"] = this.invitationDate ? this.invitationDate.toISOString() : <any>undefined;
        data["invitationSentUserId"] = this.invitationSentUserId;
        data["justificationAccepted"] = this.justificationAccepted;
        data["decisionDate"] = this.decisionDate ? this.decisionDate.toISOString() : <any>undefined;
        data["decisionDescription"] = this.decisionDescription;
        data["cancelledWithDocuments"] = this.cancelledWithDocuments;
        return data;
    }
}

export interface ISelectOneProgramApplicationData {
    id?: number;
    programId?: number;
    participantId?: number;
    applicationDate?: Date | undefined;
    applicationStatusId?: number;
    cancelledDate?: Date | undefined;
    cancelledDescription?: string | undefined;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
    invitationDate?: Date | undefined;
    invitationSentUserId?: number | undefined;
    justificationAccepted?: boolean | undefined;
    decisionDate?: Date | undefined;
    decisionDescription?: string | undefined;
    cancelledWithDocuments?: boolean | undefined;
}

export class SelectOneProgramApplicationDataUsersResult implements ISelectOneProgramApplicationDataUsersResult {
    status?: UsersResultStatus;
    content?: SelectOneProgramApplicationData;

    constructor(data?: ISelectOneProgramApplicationDataUsersResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.content = _data["content"] ? SelectOneProgramApplicationData.fromJS(_data["content"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SelectOneProgramApplicationDataUsersResult {
        data = typeof data === 'object' ? data : {};
        let result = new SelectOneProgramApplicationDataUsersResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISelectOneProgramApplicationDataUsersResult {
    status?: UsersResultStatus;
    content?: SelectOneProgramApplicationData;
}

export class SelectAllProgramDaysData implements ISelectAllProgramDaysData {
    id?: number;
    programId?: number;
    dayId?: number;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
    dateAndTime?: Date | undefined;
    dayName?: string | undefined;
    topic?: string | undefined;
    onlineLink?: string | undefined;
    trainerInvitationId?: number | undefined;
    trainerName?: string | undefined;
    trainerSurname?: string | undefined;
    trainerQuestionnaireId?: number | undefined;
    trainerSurveyId?: number | undefined;
    programDayAttendanceId?: number | undefined;

    constructor(data?: ISelectAllProgramDaysData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.programId = _data["programId"];
            this.dayId = _data["dayId"];
            this.userIdIns = _data["userIdIns"];
            this.timeIns = _data["timeIns"] ? new Date(_data["timeIns"].toString()) : <any>undefined;
            this.userIdChg = _data["userIdChg"];
            this.timeChg = _data["timeChg"] ? new Date(_data["timeChg"].toString()) : <any>undefined;
            this.dateAndTime = _data["dateAndTime"] ? new Date(_data["dateAndTime"].toString()) : <any>undefined;
            this.dayName = _data["dayName"];
            this.topic = _data["topic"];
            this.onlineLink = _data["onlineLink"];
            this.trainerInvitationId = _data["trainerInvitationId"];
            this.trainerName = _data["trainerName"];
            this.trainerSurname = _data["trainerSurname"];
            this.trainerQuestionnaireId = _data["trainerQuestionnaireId"];
            this.trainerSurveyId = _data["trainerSurveyId"];
            this.programDayAttendanceId = _data["programDayAttendanceId"];
        }
    }

    static fromJS(data: any): SelectAllProgramDaysData {
        data = typeof data === 'object' ? data : {};
        let result = new SelectAllProgramDaysData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["programId"] = this.programId;
        data["dayId"] = this.dayId;
        data["userIdIns"] = this.userIdIns;
        data["timeIns"] = this.timeIns ? this.timeIns.toISOString() : <any>undefined;
        data["userIdChg"] = this.userIdChg;
        data["timeChg"] = this.timeChg ? this.timeChg.toISOString() : <any>undefined;
        data["dateAndTime"] = this.dateAndTime ? this.dateAndTime.toISOString() : <any>undefined;
        data["dayName"] = this.dayName;
        data["topic"] = this.topic;
        data["onlineLink"] = this.onlineLink;
        data["trainerInvitationId"] = this.trainerInvitationId;
        data["trainerName"] = this.trainerName;
        data["trainerSurname"] = this.trainerSurname;
        data["trainerQuestionnaireId"] = this.trainerQuestionnaireId;
        data["trainerSurveyId"] = this.trainerSurveyId;
        data["programDayAttendanceId"] = this.programDayAttendanceId;
        return data;
    }
}

export interface ISelectAllProgramDaysData {
    id?: number;
    programId?: number;
    dayId?: number;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
    dateAndTime?: Date | undefined;
    dayName?: string | undefined;
    topic?: string | undefined;
    onlineLink?: string | undefined;
    trainerInvitationId?: number | undefined;
    trainerName?: string | undefined;
    trainerSurname?: string | undefined;
    trainerQuestionnaireId?: number | undefined;
    trainerSurveyId?: number | undefined;
    programDayAttendanceId?: number | undefined;
}

export class SelectAllProgramDaysDataPagedModel implements ISelectAllProgramDaysDataPagedModel {
    totalItems?: number;
    items?: SelectAllProgramDaysData[] | undefined;

    constructor(data?: ISelectAllProgramDaysDataPagedModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItems = _data["totalItems"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SelectAllProgramDaysData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SelectAllProgramDaysDataPagedModel {
        data = typeof data === 'object' ? data : {};
        let result = new SelectAllProgramDaysDataPagedModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItems"] = this.totalItems;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISelectAllProgramDaysDataPagedModel {
    totalItems?: number;
    items?: SelectAllProgramDaysData[] | undefined;
}

export class SelectAllProgramDaysDataPagedModelUsersResult implements ISelectAllProgramDaysDataPagedModelUsersResult {
    status?: UsersResultStatus;
    content?: SelectAllProgramDaysDataPagedModel;

    constructor(data?: ISelectAllProgramDaysDataPagedModelUsersResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.content = _data["content"] ? SelectAllProgramDaysDataPagedModel.fromJS(_data["content"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SelectAllProgramDaysDataPagedModelUsersResult {
        data = typeof data === 'object' ? data : {};
        let result = new SelectAllProgramDaysDataPagedModelUsersResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISelectAllProgramDaysDataPagedModelUsersResult {
    status?: UsersResultStatus;
    content?: SelectAllProgramDaysDataPagedModel;
}

export class ProgramDayData implements IProgramDayData {
    id?: number;
    programId?: number;
    dayId?: number;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
    dateAndTime?: Date | undefined;
    topic?: string | undefined;
    onlineLink?: string | undefined;

    constructor(data?: IProgramDayData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.programId = _data["programId"];
            this.dayId = _data["dayId"];
            this.userIdIns = _data["userIdIns"];
            this.timeIns = _data["timeIns"] ? new Date(_data["timeIns"].toString()) : <any>undefined;
            this.userIdChg = _data["userIdChg"];
            this.timeChg = _data["timeChg"] ? new Date(_data["timeChg"].toString()) : <any>undefined;
            this.dateAndTime = _data["dateAndTime"] ? new Date(_data["dateAndTime"].toString()) : <any>undefined;
            this.topic = _data["topic"];
            this.onlineLink = _data["onlineLink"];
        }
    }

    static fromJS(data: any): ProgramDayData {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramDayData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["programId"] = this.programId;
        data["dayId"] = this.dayId;
        data["userIdIns"] = this.userIdIns;
        data["timeIns"] = this.timeIns ? this.timeIns.toISOString() : <any>undefined;
        data["userIdChg"] = this.userIdChg;
        data["timeChg"] = this.timeChg ? this.timeChg.toISOString() : <any>undefined;
        data["dateAndTime"] = this.dateAndTime ? this.dateAndTime.toISOString() : <any>undefined;
        data["topic"] = this.topic;
        data["onlineLink"] = this.onlineLink;
        return data;
    }
}

export interface IProgramDayData {
    id?: number;
    programId?: number;
    dayId?: number;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
    dateAndTime?: Date | undefined;
    topic?: string | undefined;
    onlineLink?: string | undefined;
}

export class ProgramQuestionnaireAnswerData implements IProgramQuestionnaireAnswerData {
    id?: number;
    answer?: number;
    programQuestionnaireQuestionId?: number | undefined;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;

    constructor(data?: IProgramQuestionnaireAnswerData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.answer = _data["answer"];
            this.programQuestionnaireQuestionId = _data["programQuestionnaireQuestionId"];
            this.userIdIns = _data["userIdIns"];
            this.timeIns = _data["timeIns"] ? new Date(_data["timeIns"].toString()) : <any>undefined;
            this.userIdChg = _data["userIdChg"];
            this.timeChg = _data["timeChg"] ? new Date(_data["timeChg"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ProgramQuestionnaireAnswerData {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramQuestionnaireAnswerData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["answer"] = this.answer;
        data["programQuestionnaireQuestionId"] = this.programQuestionnaireQuestionId;
        data["userIdIns"] = this.userIdIns;
        data["timeIns"] = this.timeIns ? this.timeIns.toISOString() : <any>undefined;
        data["userIdChg"] = this.userIdChg;
        data["timeChg"] = this.timeChg ? this.timeChg.toISOString() : <any>undefined;
        return data;
    }
}

export interface IProgramQuestionnaireAnswerData {
    id?: number;
    answer?: number;
    programQuestionnaireQuestionId?: number | undefined;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
}

export class ProgramQuestionnaireQuestionData implements IProgramQuestionnaireQuestionData {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    active?: boolean;
    programQuestionnaireId?: number | undefined;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
    answers?: ProgramQuestionnaireAnswerData[] | undefined;
    programQuestionnaireAnswerId?: number | undefined;

    constructor(data?: IProgramQuestionnaireQuestionData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.active = _data["active"];
            this.programQuestionnaireId = _data["programQuestionnaireId"];
            this.userIdIns = _data["userIdIns"];
            this.timeIns = _data["timeIns"] ? new Date(_data["timeIns"].toString()) : <any>undefined;
            this.userIdChg = _data["userIdChg"];
            this.timeChg = _data["timeChg"] ? new Date(_data["timeChg"].toString()) : <any>undefined;
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(ProgramQuestionnaireAnswerData.fromJS(item));
            }
            this.programQuestionnaireAnswerId = _data["programQuestionnaireAnswerId"];
        }
    }

    static fromJS(data: any): ProgramQuestionnaireQuestionData {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramQuestionnaireQuestionData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["active"] = this.active;
        data["programQuestionnaireId"] = this.programQuestionnaireId;
        data["userIdIns"] = this.userIdIns;
        data["timeIns"] = this.timeIns ? this.timeIns.toISOString() : <any>undefined;
        data["userIdChg"] = this.userIdChg;
        data["timeChg"] = this.timeChg ? this.timeChg.toISOString() : <any>undefined;
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        data["programQuestionnaireAnswerId"] = this.programQuestionnaireAnswerId;
        return data;
    }
}

export interface IProgramQuestionnaireQuestionData {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    active?: boolean;
    programQuestionnaireId?: number | undefined;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
    answers?: ProgramQuestionnaireAnswerData[] | undefined;
    programQuestionnaireAnswerId?: number | undefined;
}

export class ProgramQuestionnaireData implements IProgramQuestionnaireData {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    active?: boolean;
    programTypeId?: number | undefined;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
    totalItems?: number;
    questions?: ProgramQuestionnaireQuestionData[] | undefined;

    constructor(data?: IProgramQuestionnaireData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.active = _data["active"];
            this.programTypeId = _data["programTypeId"];
            this.userIdIns = _data["userIdIns"];
            this.timeIns = _data["timeIns"] ? new Date(_data["timeIns"].toString()) : <any>undefined;
            this.userIdChg = _data["userIdChg"];
            this.timeChg = _data["timeChg"] ? new Date(_data["timeChg"].toString()) : <any>undefined;
            this.totalItems = _data["totalItems"];
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(ProgramQuestionnaireQuestionData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProgramQuestionnaireData {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramQuestionnaireData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["active"] = this.active;
        data["programTypeId"] = this.programTypeId;
        data["userIdIns"] = this.userIdIns;
        data["timeIns"] = this.timeIns ? this.timeIns.toISOString() : <any>undefined;
        data["userIdChg"] = this.userIdChg;
        data["timeChg"] = this.timeChg ? this.timeChg.toISOString() : <any>undefined;
        data["totalItems"] = this.totalItems;
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProgramQuestionnaireData {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    active?: boolean;
    programTypeId?: number | undefined;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
    totalItems?: number;
    questions?: ProgramQuestionnaireQuestionData[] | undefined;
}

export class ProgramQuestionnaireDataUsersResult implements IProgramQuestionnaireDataUsersResult {
    status?: UsersResultStatus;
    content?: ProgramQuestionnaireData;

    constructor(data?: IProgramQuestionnaireDataUsersResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.content = _data["content"] ? ProgramQuestionnaireData.fromJS(_data["content"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProgramQuestionnaireDataUsersResult {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramQuestionnaireDataUsersResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProgramQuestionnaireDataUsersResult {
    status?: UsersResultStatus;
    content?: ProgramQuestionnaireData;
}

export class InsertProgramSurveyRequestData implements IInsertProgramSurveyRequestData {
    programId?: number;
    programQuestionnaireId?: number;
    answers?: number[] | undefined;

    constructor(data?: IInsertProgramSurveyRequestData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.programId = _data["programId"];
            this.programQuestionnaireId = _data["programQuestionnaireId"];
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(item);
            }
        }
    }

    static fromJS(data: any): InsertProgramSurveyRequestData {
        data = typeof data === 'object' ? data : {};
        let result = new InsertProgramSurveyRequestData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["programId"] = this.programId;
        data["programQuestionnaireId"] = this.programQuestionnaireId;
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item);
        }
        return data;
    }
}

export interface IInsertProgramSurveyRequestData {
    programId?: number;
    programQuestionnaireId?: number;
    answers?: number[] | undefined;
}

export class TrainerApplicationAttachmentData implements ITrainerApplicationAttachmentData {
    id?: number;
    trainerInvitationId?: number;
    name?: string | undefined;
    fileName?: string | undefined;
    path?: string | undefined;
    timeIns?: Date;
    userIdIns?: number | undefined;

    constructor(data?: ITrainerApplicationAttachmentData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.trainerInvitationId = _data["trainerInvitationId"];
            this.name = _data["name"];
            this.fileName = _data["fileName"];
            this.path = _data["path"];
            this.timeIns = _data["timeIns"] ? new Date(_data["timeIns"].toString()) : <any>undefined;
            this.userIdIns = _data["userIdIns"];
        }
    }

    static fromJS(data: any): TrainerApplicationAttachmentData {
        data = typeof data === 'object' ? data : {};
        let result = new TrainerApplicationAttachmentData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["trainerInvitationId"] = this.trainerInvitationId;
        data["name"] = this.name;
        data["fileName"] = this.fileName;
        data["path"] = this.path;
        data["timeIns"] = this.timeIns ? this.timeIns.toISOString() : <any>undefined;
        data["userIdIns"] = this.userIdIns;
        return data;
    }
}

export interface ITrainerApplicationAttachmentData {
    id?: number;
    trainerInvitationId?: number;
    name?: string | undefined;
    fileName?: string | undefined;
    path?: string | undefined;
    timeIns?: Date;
    userIdIns?: number | undefined;
}

export class TrainerApplicationAttachmentDataPagedModel implements ITrainerApplicationAttachmentDataPagedModel {
    totalItems?: number;
    items?: TrainerApplicationAttachmentData[] | undefined;

    constructor(data?: ITrainerApplicationAttachmentDataPagedModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItems = _data["totalItems"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TrainerApplicationAttachmentData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TrainerApplicationAttachmentDataPagedModel {
        data = typeof data === 'object' ? data : {};
        let result = new TrainerApplicationAttachmentDataPagedModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItems"] = this.totalItems;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITrainerApplicationAttachmentDataPagedModel {
    totalItems?: number;
    items?: TrainerApplicationAttachmentData[] | undefined;
}

export class TrainerApplicationAttachmentDataPagedModelUsersResult implements ITrainerApplicationAttachmentDataPagedModelUsersResult {
    status?: UsersResultStatus;
    content?: TrainerApplicationAttachmentDataPagedModel;

    constructor(data?: ITrainerApplicationAttachmentDataPagedModelUsersResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.content = _data["content"] ? TrainerApplicationAttachmentDataPagedModel.fromJS(_data["content"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainerApplicationAttachmentDataPagedModelUsersResult {
        data = typeof data === 'object' ? data : {};
        let result = new TrainerApplicationAttachmentDataPagedModelUsersResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITrainerApplicationAttachmentDataPagedModelUsersResult {
    status?: UsersResultStatus;
    content?: TrainerApplicationAttachmentDataPagedModel;
}

export class SelectAllTrainerCertificatesData implements ISelectAllTrainerCertificatesData {
    id?: number;
    trainerId?: number;
    certificateTypeId?: number;
    certificateTypeName?: string | undefined;
    durationInYears?: number | undefined;
    validFromDate?: Date;
    validToDate?: Date;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
    acquiredDate?: Date;
    providerId?: number;
    providerName?: string | undefined;

    constructor(data?: ISelectAllTrainerCertificatesData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.trainerId = _data["trainerId"];
            this.certificateTypeId = _data["certificateTypeId"];
            this.certificateTypeName = _data["certificateTypeName"];
            this.durationInYears = _data["durationInYears"];
            this.validFromDate = _data["validFromDate"] ? new Date(_data["validFromDate"].toString()) : <any>undefined;
            this.validToDate = _data["validToDate"] ? new Date(_data["validToDate"].toString()) : <any>undefined;
            this.userIdIns = _data["userIdIns"];
            this.timeIns = _data["timeIns"] ? new Date(_data["timeIns"].toString()) : <any>undefined;
            this.userIdChg = _data["userIdChg"];
            this.timeChg = _data["timeChg"] ? new Date(_data["timeChg"].toString()) : <any>undefined;
            this.acquiredDate = _data["acquiredDate"] ? new Date(_data["acquiredDate"].toString()) : <any>undefined;
            this.providerId = _data["providerId"];
            this.providerName = _data["providerName"];
        }
    }

    static fromJS(data: any): SelectAllTrainerCertificatesData {
        data = typeof data === 'object' ? data : {};
        let result = new SelectAllTrainerCertificatesData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["trainerId"] = this.trainerId;
        data["certificateTypeId"] = this.certificateTypeId;
        data["certificateTypeName"] = this.certificateTypeName;
        data["durationInYears"] = this.durationInYears;
        data["validFromDate"] = this.validFromDate ? this.validFromDate.toISOString() : <any>undefined;
        data["validToDate"] = this.validToDate ? this.validToDate.toISOString() : <any>undefined;
        data["userIdIns"] = this.userIdIns;
        data["timeIns"] = this.timeIns ? this.timeIns.toISOString() : <any>undefined;
        data["userIdChg"] = this.userIdChg;
        data["timeChg"] = this.timeChg ? this.timeChg.toISOString() : <any>undefined;
        data["acquiredDate"] = this.acquiredDate ? this.acquiredDate.toISOString() : <any>undefined;
        data["providerId"] = this.providerId;
        data["providerName"] = this.providerName;
        return data;
    }
}

export interface ISelectAllTrainerCertificatesData {
    id?: number;
    trainerId?: number;
    certificateTypeId?: number;
    certificateTypeName?: string | undefined;
    durationInYears?: number | undefined;
    validFromDate?: Date;
    validToDate?: Date;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
    acquiredDate?: Date;
    providerId?: number;
    providerName?: string | undefined;
}

export class SelectAllTrainerCertificatesDataPagedModel implements ISelectAllTrainerCertificatesDataPagedModel {
    totalItems?: number;
    items?: SelectAllTrainerCertificatesData[] | undefined;

    constructor(data?: ISelectAllTrainerCertificatesDataPagedModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItems = _data["totalItems"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SelectAllTrainerCertificatesData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SelectAllTrainerCertificatesDataPagedModel {
        data = typeof data === 'object' ? data : {};
        let result = new SelectAllTrainerCertificatesDataPagedModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItems"] = this.totalItems;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISelectAllTrainerCertificatesDataPagedModel {
    totalItems?: number;
    items?: SelectAllTrainerCertificatesData[] | undefined;
}

export class SelectAllTrainerCertificatesDataPagedModelUsersResult implements ISelectAllTrainerCertificatesDataPagedModelUsersResult {
    status?: UsersResultStatus;
    content?: SelectAllTrainerCertificatesDataPagedModel;

    constructor(data?: ISelectAllTrainerCertificatesDataPagedModelUsersResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.content = _data["content"] ? SelectAllTrainerCertificatesDataPagedModel.fromJS(_data["content"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SelectAllTrainerCertificatesDataPagedModelUsersResult {
        data = typeof data === 'object' ? data : {};
        let result = new SelectAllTrainerCertificatesDataPagedModelUsersResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISelectAllTrainerCertificatesDataPagedModelUsersResult {
    status?: UsersResultStatus;
    content?: SelectAllTrainerCertificatesDataPagedModel;
}

export class InsertTrainerCertificateRequestData implements IInsertTrainerCertificateRequestData {
    trainerId?: number;
    certificateTypeId?: number;
    durationInYears?: number | undefined;
    acquiredDate?: Date;
    number?: string | undefined;
    providerId?: number;
    validFromDate?: Date;
    validToDate?: Date;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;

    constructor(data?: IInsertTrainerCertificateRequestData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainerId = _data["trainerId"];
            this.certificateTypeId = _data["certificateTypeId"];
            this.durationInYears = _data["durationInYears"];
            this.acquiredDate = _data["acquiredDate"] ? new Date(_data["acquiredDate"].toString()) : <any>undefined;
            this.number = _data["number"];
            this.providerId = _data["providerId"];
            this.validFromDate = _data["validFromDate"] ? new Date(_data["validFromDate"].toString()) : <any>undefined;
            this.validToDate = _data["validToDate"] ? new Date(_data["validToDate"].toString()) : <any>undefined;
            this.userIdIns = _data["userIdIns"];
            this.timeIns = _data["timeIns"] ? new Date(_data["timeIns"].toString()) : <any>undefined;
            this.userIdChg = _data["userIdChg"];
            this.timeChg = _data["timeChg"] ? new Date(_data["timeChg"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): InsertTrainerCertificateRequestData {
        data = typeof data === 'object' ? data : {};
        let result = new InsertTrainerCertificateRequestData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainerId"] = this.trainerId;
        data["certificateTypeId"] = this.certificateTypeId;
        data["durationInYears"] = this.durationInYears;
        data["acquiredDate"] = this.acquiredDate ? this.acquiredDate.toISOString() : <any>undefined;
        data["number"] = this.number;
        data["providerId"] = this.providerId;
        data["validFromDate"] = this.validFromDate ? this.validFromDate.toISOString() : <any>undefined;
        data["validToDate"] = this.validToDate ? this.validToDate.toISOString() : <any>undefined;
        data["userIdIns"] = this.userIdIns;
        data["timeIns"] = this.timeIns ? this.timeIns.toISOString() : <any>undefined;
        data["userIdChg"] = this.userIdChg;
        data["timeChg"] = this.timeChg ? this.timeChg.toISOString() : <any>undefined;
        return data;
    }
}

export interface IInsertTrainerCertificateRequestData {
    trainerId?: number;
    certificateTypeId?: number;
    durationInYears?: number | undefined;
    acquiredDate?: Date;
    number?: string | undefined;
    providerId?: number;
    validFromDate?: Date;
    validToDate?: Date;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
}

export class TrainerCertificateData implements ITrainerCertificateData {
    id?: number;
    trainerId?: number;
    certificateTypeId?: number;
    durationInYears?: number | undefined;
    acquiredDate?: Date;
    number?: string | undefined;
    providerId?: number;
    validFromDate?: Date;
    validToDate?: Date;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;

    constructor(data?: ITrainerCertificateData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.trainerId = _data["trainerId"];
            this.certificateTypeId = _data["certificateTypeId"];
            this.durationInYears = _data["durationInYears"];
            this.acquiredDate = _data["acquiredDate"] ? new Date(_data["acquiredDate"].toString()) : <any>undefined;
            this.number = _data["number"];
            this.providerId = _data["providerId"];
            this.validFromDate = _data["validFromDate"] ? new Date(_data["validFromDate"].toString()) : <any>undefined;
            this.validToDate = _data["validToDate"] ? new Date(_data["validToDate"].toString()) : <any>undefined;
            this.userIdIns = _data["userIdIns"];
            this.timeIns = _data["timeIns"] ? new Date(_data["timeIns"].toString()) : <any>undefined;
            this.userIdChg = _data["userIdChg"];
            this.timeChg = _data["timeChg"] ? new Date(_data["timeChg"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainerCertificateData {
        data = typeof data === 'object' ? data : {};
        let result = new TrainerCertificateData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["trainerId"] = this.trainerId;
        data["certificateTypeId"] = this.certificateTypeId;
        data["durationInYears"] = this.durationInYears;
        data["acquiredDate"] = this.acquiredDate ? this.acquiredDate.toISOString() : <any>undefined;
        data["number"] = this.number;
        data["providerId"] = this.providerId;
        data["validFromDate"] = this.validFromDate ? this.validFromDate.toISOString() : <any>undefined;
        data["validToDate"] = this.validToDate ? this.validToDate.toISOString() : <any>undefined;
        data["userIdIns"] = this.userIdIns;
        data["timeIns"] = this.timeIns ? this.timeIns.toISOString() : <any>undefined;
        data["userIdChg"] = this.userIdChg;
        data["timeChg"] = this.timeChg ? this.timeChg.toISOString() : <any>undefined;
        return data;
    }
}

export interface ITrainerCertificateData {
    id?: number;
    trainerId?: number;
    certificateTypeId?: number;
    durationInYears?: number | undefined;
    acquiredDate?: Date;
    number?: string | undefined;
    providerId?: number;
    validFromDate?: Date;
    validToDate?: Date;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
}

export class TrainerCertificateDataUsersResult implements ITrainerCertificateDataUsersResult {
    status?: UsersResultStatus;
    content?: TrainerCertificateData;

    constructor(data?: ITrainerCertificateDataUsersResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.content = _data["content"] ? TrainerCertificateData.fromJS(_data["content"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainerCertificateDataUsersResult {
        data = typeof data === 'object' ? data : {};
        let result = new TrainerCertificateDataUsersResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITrainerCertificateDataUsersResult {
    status?: UsersResultStatus;
    content?: TrainerCertificateData;
}

export class SelectAllTrainerCertificatesForRegisterData implements ISelectAllTrainerCertificatesForRegisterData {
    id?: number;
    trainerId?: number;
    trainerName?: string | undefined;
    trainerSurname?: string | undefined;
    institutionName?: string | undefined;
    acquiredDate?: Date | undefined;
    validFromDate?: Date | undefined;
    validToDate?: Date | undefined;

    constructor(data?: ISelectAllTrainerCertificatesForRegisterData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.trainerId = _data["trainerId"];
            this.trainerName = _data["trainerName"];
            this.trainerSurname = _data["trainerSurname"];
            this.institutionName = _data["institutionName"];
            this.acquiredDate = _data["acquiredDate"] ? new Date(_data["acquiredDate"].toString()) : <any>undefined;
            this.validFromDate = _data["validFromDate"] ? new Date(_data["validFromDate"].toString()) : <any>undefined;
            this.validToDate = _data["validToDate"] ? new Date(_data["validToDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SelectAllTrainerCertificatesForRegisterData {
        data = typeof data === 'object' ? data : {};
        let result = new SelectAllTrainerCertificatesForRegisterData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["trainerId"] = this.trainerId;
        data["trainerName"] = this.trainerName;
        data["trainerSurname"] = this.trainerSurname;
        data["institutionName"] = this.institutionName;
        data["acquiredDate"] = this.acquiredDate ? this.acquiredDate.toISOString() : <any>undefined;
        data["validFromDate"] = this.validFromDate ? this.validFromDate.toISOString() : <any>undefined;
        data["validToDate"] = this.validToDate ? this.validToDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface ISelectAllTrainerCertificatesForRegisterData {
    id?: number;
    trainerId?: number;
    trainerName?: string | undefined;
    trainerSurname?: string | undefined;
    institutionName?: string | undefined;
    acquiredDate?: Date | undefined;
    validFromDate?: Date | undefined;
    validToDate?: Date | undefined;
}

export class SelectAllTrainerCertificatesForRegisterDataPagedModel implements ISelectAllTrainerCertificatesForRegisterDataPagedModel {
    totalItems?: number;
    items?: SelectAllTrainerCertificatesForRegisterData[] | undefined;

    constructor(data?: ISelectAllTrainerCertificatesForRegisterDataPagedModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItems = _data["totalItems"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SelectAllTrainerCertificatesForRegisterData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SelectAllTrainerCertificatesForRegisterDataPagedModel {
        data = typeof data === 'object' ? data : {};
        let result = new SelectAllTrainerCertificatesForRegisterDataPagedModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItems"] = this.totalItems;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISelectAllTrainerCertificatesForRegisterDataPagedModel {
    totalItems?: number;
    items?: SelectAllTrainerCertificatesForRegisterData[] | undefined;
}

export class SelectAllTrainerCertificatesForRegisterDataPagedModelUsersResult implements ISelectAllTrainerCertificatesForRegisterDataPagedModelUsersResult {
    status?: UsersResultStatus;
    content?: SelectAllTrainerCertificatesForRegisterDataPagedModel;

    constructor(data?: ISelectAllTrainerCertificatesForRegisterDataPagedModelUsersResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.content = _data["content"] ? SelectAllTrainerCertificatesForRegisterDataPagedModel.fromJS(_data["content"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SelectAllTrainerCertificatesForRegisterDataPagedModelUsersResult {
        data = typeof data === 'object' ? data : {};
        let result = new SelectAllTrainerCertificatesForRegisterDataPagedModelUsersResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISelectAllTrainerCertificatesForRegisterDataPagedModelUsersResult {
    status?: UsersResultStatus;
    content?: SelectAllTrainerCertificatesForRegisterDataPagedModel;
}

export class InsertTrainerCertificateRenewalRequestData implements IInsertTrainerCertificateRenewalRequestData {
    trainerCertificateId?: number | undefined;
    description?: string | undefined;

    constructor(data?: IInsertTrainerCertificateRenewalRequestData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainerCertificateId = _data["trainerCertificateId"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): InsertTrainerCertificateRenewalRequestData {
        data = typeof data === 'object' ? data : {};
        let result = new InsertTrainerCertificateRenewalRequestData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainerCertificateId"] = this.trainerCertificateId;
        data["description"] = this.description;
        return data;
    }
}

export interface IInsertTrainerCertificateRenewalRequestData {
    trainerCertificateId?: number | undefined;
    description?: string | undefined;
}

export class TrainerInvitationData implements ITrainerInvitationData {
    id?: number;
    programDayId?: number;
    trainerId?: number;
    applicationStatusId?: number;
    cancelledDate?: Date | undefined;
    cancelledDescription?: string | undefined;
    invitationDate?: Date | undefined;
    invitationSentUserId?: number | undefined;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
    answerDate?: Date | undefined;
    justificationAccepted?: boolean | undefined;
    decisionDate?: Date | undefined;
    cancelledWithDocuments?: boolean | undefined;
    dayId?: number;
    dayName?: string | undefined;
    dateAndTime?: Date | undefined;
    topic?: string | undefined;
    programName?: string | undefined;
    averageGrade?: number | undefined;

    constructor(data?: ITrainerInvitationData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.programDayId = _data["programDayId"];
            this.trainerId = _data["trainerId"];
            this.applicationStatusId = _data["applicationStatusId"];
            this.cancelledDate = _data["cancelledDate"] ? new Date(_data["cancelledDate"].toString()) : <any>undefined;
            this.cancelledDescription = _data["cancelledDescription"];
            this.invitationDate = _data["invitationDate"] ? new Date(_data["invitationDate"].toString()) : <any>undefined;
            this.invitationSentUserId = _data["invitationSentUserId"];
            this.userIdIns = _data["userIdIns"];
            this.timeIns = _data["timeIns"] ? new Date(_data["timeIns"].toString()) : <any>undefined;
            this.userIdChg = _data["userIdChg"];
            this.timeChg = _data["timeChg"] ? new Date(_data["timeChg"].toString()) : <any>undefined;
            this.answerDate = _data["answerDate"] ? new Date(_data["answerDate"].toString()) : <any>undefined;
            this.justificationAccepted = _data["justificationAccepted"];
            this.decisionDate = _data["decisionDate"] ? new Date(_data["decisionDate"].toString()) : <any>undefined;
            this.cancelledWithDocuments = _data["cancelledWithDocuments"];
            this.dayId = _data["dayId"];
            this.dayName = _data["dayName"];
            this.dateAndTime = _data["dateAndTime"] ? new Date(_data["dateAndTime"].toString()) : <any>undefined;
            this.topic = _data["topic"];
            this.programName = _data["programName"];
            this.averageGrade = _data["averageGrade"];
        }
    }

    static fromJS(data: any): TrainerInvitationData {
        data = typeof data === 'object' ? data : {};
        let result = new TrainerInvitationData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["programDayId"] = this.programDayId;
        data["trainerId"] = this.trainerId;
        data["applicationStatusId"] = this.applicationStatusId;
        data["cancelledDate"] = this.cancelledDate ? this.cancelledDate.toISOString() : <any>undefined;
        data["cancelledDescription"] = this.cancelledDescription;
        data["invitationDate"] = this.invitationDate ? this.invitationDate.toISOString() : <any>undefined;
        data["invitationSentUserId"] = this.invitationSentUserId;
        data["userIdIns"] = this.userIdIns;
        data["timeIns"] = this.timeIns ? this.timeIns.toISOString() : <any>undefined;
        data["userIdChg"] = this.userIdChg;
        data["timeChg"] = this.timeChg ? this.timeChg.toISOString() : <any>undefined;
        data["answerDate"] = this.answerDate ? this.answerDate.toISOString() : <any>undefined;
        data["justificationAccepted"] = this.justificationAccepted;
        data["decisionDate"] = this.decisionDate ? this.decisionDate.toISOString() : <any>undefined;
        data["cancelledWithDocuments"] = this.cancelledWithDocuments;
        data["dayId"] = this.dayId;
        data["dayName"] = this.dayName;
        data["dateAndTime"] = this.dateAndTime ? this.dateAndTime.toISOString() : <any>undefined;
        data["topic"] = this.topic;
        data["programName"] = this.programName;
        data["averageGrade"] = this.averageGrade;
        return data;
    }
}

export interface ITrainerInvitationData {
    id?: number;
    programDayId?: number;
    trainerId?: number;
    applicationStatusId?: number;
    cancelledDate?: Date | undefined;
    cancelledDescription?: string | undefined;
    invitationDate?: Date | undefined;
    invitationSentUserId?: number | undefined;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
    answerDate?: Date | undefined;
    justificationAccepted?: boolean | undefined;
    decisionDate?: Date | undefined;
    cancelledWithDocuments?: boolean | undefined;
    dayId?: number;
    dayName?: string | undefined;
    dateAndTime?: Date | undefined;
    topic?: string | undefined;
    programName?: string | undefined;
    averageGrade?: number | undefined;
}

export class TrainerInvitationDataPagedModel implements ITrainerInvitationDataPagedModel {
    totalItems?: number;
    items?: TrainerInvitationData[] | undefined;

    constructor(data?: ITrainerInvitationDataPagedModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItems = _data["totalItems"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TrainerInvitationData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TrainerInvitationDataPagedModel {
        data = typeof data === 'object' ? data : {};
        let result = new TrainerInvitationDataPagedModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItems"] = this.totalItems;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITrainerInvitationDataPagedModel {
    totalItems?: number;
    items?: TrainerInvitationData[] | undefined;
}

export class TrainerInvitationDataPagedModelUsersResult implements ITrainerInvitationDataPagedModelUsersResult {
    status?: UsersResultStatus;
    content?: TrainerInvitationDataPagedModel;

    constructor(data?: ITrainerInvitationDataPagedModelUsersResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.content = _data["content"] ? TrainerInvitationDataPagedModel.fromJS(_data["content"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainerInvitationDataPagedModelUsersResult {
        data = typeof data === 'object' ? data : {};
        let result = new TrainerInvitationDataPagedModelUsersResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITrainerInvitationDataPagedModelUsersResult {
    status?: UsersResultStatus;
    content?: TrainerInvitationDataPagedModel;
}

export class TrainerInvitationForMaterialsData implements ITrainerInvitationForMaterialsData {
    id?: number;
    programDayId?: number;
    trainerId?: number;
    applicationStatusId?: number;
    cancelledDate?: Date | undefined;
    cancelledDescription?: string | undefined;
    invitationDate?: Date | undefined;
    invitationSentUserId?: number | undefined;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
    answerDate?: Date | undefined;
    dayId?: number;
    dayName?: string | undefined;
    dateAndTime?: Date | undefined;
    topic?: string | undefined;
    programName?: string | undefined;
    active?: boolean;
    online?: boolean;
    year?: number;
    uploadedPresentations?: number;

    constructor(data?: ITrainerInvitationForMaterialsData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.programDayId = _data["programDayId"];
            this.trainerId = _data["trainerId"];
            this.applicationStatusId = _data["applicationStatusId"];
            this.cancelledDate = _data["cancelledDate"] ? new Date(_data["cancelledDate"].toString()) : <any>undefined;
            this.cancelledDescription = _data["cancelledDescription"];
            this.invitationDate = _data["invitationDate"] ? new Date(_data["invitationDate"].toString()) : <any>undefined;
            this.invitationSentUserId = _data["invitationSentUserId"];
            this.userIdIns = _data["userIdIns"];
            this.timeIns = _data["timeIns"] ? new Date(_data["timeIns"].toString()) : <any>undefined;
            this.userIdChg = _data["userIdChg"];
            this.timeChg = _data["timeChg"] ? new Date(_data["timeChg"].toString()) : <any>undefined;
            this.answerDate = _data["answerDate"] ? new Date(_data["answerDate"].toString()) : <any>undefined;
            this.dayId = _data["dayId"];
            this.dayName = _data["dayName"];
            this.dateAndTime = _data["dateAndTime"] ? new Date(_data["dateAndTime"].toString()) : <any>undefined;
            this.topic = _data["topic"];
            this.programName = _data["programName"];
            this.active = _data["active"];
            this.online = _data["online"];
            this.year = _data["year"];
            this.uploadedPresentations = _data["uploadedPresentations"];
        }
    }

    static fromJS(data: any): TrainerInvitationForMaterialsData {
        data = typeof data === 'object' ? data : {};
        let result = new TrainerInvitationForMaterialsData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["programDayId"] = this.programDayId;
        data["trainerId"] = this.trainerId;
        data["applicationStatusId"] = this.applicationStatusId;
        data["cancelledDate"] = this.cancelledDate ? this.cancelledDate.toISOString() : <any>undefined;
        data["cancelledDescription"] = this.cancelledDescription;
        data["invitationDate"] = this.invitationDate ? this.invitationDate.toISOString() : <any>undefined;
        data["invitationSentUserId"] = this.invitationSentUserId;
        data["userIdIns"] = this.userIdIns;
        data["timeIns"] = this.timeIns ? this.timeIns.toISOString() : <any>undefined;
        data["userIdChg"] = this.userIdChg;
        data["timeChg"] = this.timeChg ? this.timeChg.toISOString() : <any>undefined;
        data["answerDate"] = this.answerDate ? this.answerDate.toISOString() : <any>undefined;
        data["dayId"] = this.dayId;
        data["dayName"] = this.dayName;
        data["dateAndTime"] = this.dateAndTime ? this.dateAndTime.toISOString() : <any>undefined;
        data["topic"] = this.topic;
        data["programName"] = this.programName;
        data["active"] = this.active;
        data["online"] = this.online;
        data["year"] = this.year;
        data["uploadedPresentations"] = this.uploadedPresentations;
        return data;
    }
}

export interface ITrainerInvitationForMaterialsData {
    id?: number;
    programDayId?: number;
    trainerId?: number;
    applicationStatusId?: number;
    cancelledDate?: Date | undefined;
    cancelledDescription?: string | undefined;
    invitationDate?: Date | undefined;
    invitationSentUserId?: number | undefined;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
    answerDate?: Date | undefined;
    dayId?: number;
    dayName?: string | undefined;
    dateAndTime?: Date | undefined;
    topic?: string | undefined;
    programName?: string | undefined;
    active?: boolean;
    online?: boolean;
    year?: number;
    uploadedPresentations?: number;
}

export class TrainerInvitationForMaterialsDataPagedModel implements ITrainerInvitationForMaterialsDataPagedModel {
    totalItems?: number;
    items?: TrainerInvitationForMaterialsData[] | undefined;

    constructor(data?: ITrainerInvitationForMaterialsDataPagedModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItems = _data["totalItems"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TrainerInvitationForMaterialsData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TrainerInvitationForMaterialsDataPagedModel {
        data = typeof data === 'object' ? data : {};
        let result = new TrainerInvitationForMaterialsDataPagedModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItems"] = this.totalItems;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITrainerInvitationForMaterialsDataPagedModel {
    totalItems?: number;
    items?: TrainerInvitationForMaterialsData[] | undefined;
}

export class TrainerInvitationForMaterialsDataPagedModelUsersResult implements ITrainerInvitationForMaterialsDataPagedModelUsersResult {
    status?: UsersResultStatus;
    content?: TrainerInvitationForMaterialsDataPagedModel;

    constructor(data?: ITrainerInvitationForMaterialsDataPagedModelUsersResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.content = _data["content"] ? TrainerInvitationForMaterialsDataPagedModel.fromJS(_data["content"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainerInvitationForMaterialsDataPagedModelUsersResult {
        data = typeof data === 'object' ? data : {};
        let result = new TrainerInvitationForMaterialsDataPagedModelUsersResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITrainerInvitationForMaterialsDataPagedModelUsersResult {
    status?: UsersResultStatus;
    content?: TrainerInvitationForMaterialsDataPagedModel;
}

export class SelectOneTrainerInvitationData implements ISelectOneTrainerInvitationData {
    id?: number;
    programDayId?: number;
    trainerId?: number;
    applicationStatusId?: number;
    cancelledDate?: Date | undefined;
    cancelledDescription?: string | undefined;
    invitationDate?: Date | undefined;
    invitationSentUserId?: number | undefined;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
    answerDate?: Date | undefined;
    decisionDescription?: string | undefined;
    justificationAccepted?: boolean | undefined;
    decisionDate?: Date | undefined;
    cancelledWithDocuments?: boolean | undefined;
    programId?: number;
    programName?: string | undefined;
    programTypeId?: number;
    dayId?: number;
    dayName?: string | undefined;
    dateAndTime?: Date | undefined;

    constructor(data?: ISelectOneTrainerInvitationData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.programDayId = _data["programDayId"];
            this.trainerId = _data["trainerId"];
            this.applicationStatusId = _data["applicationStatusId"];
            this.cancelledDate = _data["cancelledDate"] ? new Date(_data["cancelledDate"].toString()) : <any>undefined;
            this.cancelledDescription = _data["cancelledDescription"];
            this.invitationDate = _data["invitationDate"] ? new Date(_data["invitationDate"].toString()) : <any>undefined;
            this.invitationSentUserId = _data["invitationSentUserId"];
            this.userIdIns = _data["userIdIns"];
            this.timeIns = _data["timeIns"] ? new Date(_data["timeIns"].toString()) : <any>undefined;
            this.userIdChg = _data["userIdChg"];
            this.timeChg = _data["timeChg"] ? new Date(_data["timeChg"].toString()) : <any>undefined;
            this.answerDate = _data["answerDate"] ? new Date(_data["answerDate"].toString()) : <any>undefined;
            this.decisionDescription = _data["decisionDescription"];
            this.justificationAccepted = _data["justificationAccepted"];
            this.decisionDate = _data["decisionDate"] ? new Date(_data["decisionDate"].toString()) : <any>undefined;
            this.cancelledWithDocuments = _data["cancelledWithDocuments"];
            this.programId = _data["programId"];
            this.programName = _data["programName"];
            this.programTypeId = _data["programTypeId"];
            this.dayId = _data["dayId"];
            this.dayName = _data["dayName"];
            this.dateAndTime = _data["dateAndTime"] ? new Date(_data["dateAndTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SelectOneTrainerInvitationData {
        data = typeof data === 'object' ? data : {};
        let result = new SelectOneTrainerInvitationData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["programDayId"] = this.programDayId;
        data["trainerId"] = this.trainerId;
        data["applicationStatusId"] = this.applicationStatusId;
        data["cancelledDate"] = this.cancelledDate ? this.cancelledDate.toISOString() : <any>undefined;
        data["cancelledDescription"] = this.cancelledDescription;
        data["invitationDate"] = this.invitationDate ? this.invitationDate.toISOString() : <any>undefined;
        data["invitationSentUserId"] = this.invitationSentUserId;
        data["userIdIns"] = this.userIdIns;
        data["timeIns"] = this.timeIns ? this.timeIns.toISOString() : <any>undefined;
        data["userIdChg"] = this.userIdChg;
        data["timeChg"] = this.timeChg ? this.timeChg.toISOString() : <any>undefined;
        data["answerDate"] = this.answerDate ? this.answerDate.toISOString() : <any>undefined;
        data["decisionDescription"] = this.decisionDescription;
        data["justificationAccepted"] = this.justificationAccepted;
        data["decisionDate"] = this.decisionDate ? this.decisionDate.toISOString() : <any>undefined;
        data["cancelledWithDocuments"] = this.cancelledWithDocuments;
        data["programId"] = this.programId;
        data["programName"] = this.programName;
        data["programTypeId"] = this.programTypeId;
        data["dayId"] = this.dayId;
        data["dayName"] = this.dayName;
        data["dateAndTime"] = this.dateAndTime ? this.dateAndTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface ISelectOneTrainerInvitationData {
    id?: number;
    programDayId?: number;
    trainerId?: number;
    applicationStatusId?: number;
    cancelledDate?: Date | undefined;
    cancelledDescription?: string | undefined;
    invitationDate?: Date | undefined;
    invitationSentUserId?: number | undefined;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
    answerDate?: Date | undefined;
    decisionDescription?: string | undefined;
    justificationAccepted?: boolean | undefined;
    decisionDate?: Date | undefined;
    cancelledWithDocuments?: boolean | undefined;
    programId?: number;
    programName?: string | undefined;
    programTypeId?: number;
    dayId?: number;
    dayName?: string | undefined;
    dateAndTime?: Date | undefined;
}

export class SelectOneTrainerInvitationDataUsersResult implements ISelectOneTrainerInvitationDataUsersResult {
    status?: UsersResultStatus;
    content?: SelectOneTrainerInvitationData;

    constructor(data?: ISelectOneTrainerInvitationDataUsersResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.content = _data["content"] ? SelectOneTrainerInvitationData.fromJS(_data["content"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SelectOneTrainerInvitationDataUsersResult {
        data = typeof data === 'object' ? data : {};
        let result = new SelectOneTrainerInvitationDataUsersResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISelectOneTrainerInvitationDataUsersResult {
    status?: UsersResultStatus;
    content?: SelectOneTrainerInvitationData;
}

export class TrainerQuestionnaireAnswerData implements ITrainerQuestionnaireAnswerData {
    id?: number;
    answer?: number;
    trainerQuestionnaireQuestionId?: number | undefined;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;

    constructor(data?: ITrainerQuestionnaireAnswerData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.answer = _data["answer"];
            this.trainerQuestionnaireQuestionId = _data["trainerQuestionnaireQuestionId"];
            this.userIdIns = _data["userIdIns"];
            this.timeIns = _data["timeIns"] ? new Date(_data["timeIns"].toString()) : <any>undefined;
            this.userIdChg = _data["userIdChg"];
            this.timeChg = _data["timeChg"] ? new Date(_data["timeChg"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainerQuestionnaireAnswerData {
        data = typeof data === 'object' ? data : {};
        let result = new TrainerQuestionnaireAnswerData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["answer"] = this.answer;
        data["trainerQuestionnaireQuestionId"] = this.trainerQuestionnaireQuestionId;
        data["userIdIns"] = this.userIdIns;
        data["timeIns"] = this.timeIns ? this.timeIns.toISOString() : <any>undefined;
        data["userIdChg"] = this.userIdChg;
        data["timeChg"] = this.timeChg ? this.timeChg.toISOString() : <any>undefined;
        return data;
    }
}

export interface ITrainerQuestionnaireAnswerData {
    id?: number;
    answer?: number;
    trainerQuestionnaireQuestionId?: number | undefined;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
}

export class TrainerQuestionnaireQuestionData implements ITrainerQuestionnaireQuestionData {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    active?: boolean;
    trainerQuestionnaireId?: number | undefined;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
    answers?: TrainerQuestionnaireAnswerData[] | undefined;
    trainerQuestionnaireAnswerId?: number | undefined;

    constructor(data?: ITrainerQuestionnaireQuestionData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.active = _data["active"];
            this.trainerQuestionnaireId = _data["trainerQuestionnaireId"];
            this.userIdIns = _data["userIdIns"];
            this.timeIns = _data["timeIns"] ? new Date(_data["timeIns"].toString()) : <any>undefined;
            this.userIdChg = _data["userIdChg"];
            this.timeChg = _data["timeChg"] ? new Date(_data["timeChg"].toString()) : <any>undefined;
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(TrainerQuestionnaireAnswerData.fromJS(item));
            }
            this.trainerQuestionnaireAnswerId = _data["trainerQuestionnaireAnswerId"];
        }
    }

    static fromJS(data: any): TrainerQuestionnaireQuestionData {
        data = typeof data === 'object' ? data : {};
        let result = new TrainerQuestionnaireQuestionData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["active"] = this.active;
        data["trainerQuestionnaireId"] = this.trainerQuestionnaireId;
        data["userIdIns"] = this.userIdIns;
        data["timeIns"] = this.timeIns ? this.timeIns.toISOString() : <any>undefined;
        data["userIdChg"] = this.userIdChg;
        data["timeChg"] = this.timeChg ? this.timeChg.toISOString() : <any>undefined;
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item.toJSON());
        }
        data["trainerQuestionnaireAnswerId"] = this.trainerQuestionnaireAnswerId;
        return data;
    }
}

export interface ITrainerQuestionnaireQuestionData {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    active?: boolean;
    trainerQuestionnaireId?: number | undefined;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
    answers?: TrainerQuestionnaireAnswerData[] | undefined;
    trainerQuestionnaireAnswerId?: number | undefined;
}

export class TrainerQuestionnaireData implements ITrainerQuestionnaireData {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    active?: boolean;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
    totalItems?: number;
    questions?: TrainerQuestionnaireQuestionData[] | undefined;

    constructor(data?: ITrainerQuestionnaireData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.active = _data["active"];
            this.userIdIns = _data["userIdIns"];
            this.timeIns = _data["timeIns"] ? new Date(_data["timeIns"].toString()) : <any>undefined;
            this.userIdChg = _data["userIdChg"];
            this.timeChg = _data["timeChg"] ? new Date(_data["timeChg"].toString()) : <any>undefined;
            this.totalItems = _data["totalItems"];
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(TrainerQuestionnaireQuestionData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TrainerQuestionnaireData {
        data = typeof data === 'object' ? data : {};
        let result = new TrainerQuestionnaireData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["active"] = this.active;
        data["userIdIns"] = this.userIdIns;
        data["timeIns"] = this.timeIns ? this.timeIns.toISOString() : <any>undefined;
        data["userIdChg"] = this.userIdChg;
        data["timeChg"] = this.timeChg ? this.timeChg.toISOString() : <any>undefined;
        data["totalItems"] = this.totalItems;
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITrainerQuestionnaireData {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    active?: boolean;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
    totalItems?: number;
    questions?: TrainerQuestionnaireQuestionData[] | undefined;
}

export class TrainerQuestionnaireDataUsersResult implements ITrainerQuestionnaireDataUsersResult {
    status?: UsersResultStatus;
    content?: TrainerQuestionnaireData;

    constructor(data?: ITrainerQuestionnaireDataUsersResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.content = _data["content"] ? TrainerQuestionnaireData.fromJS(_data["content"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainerQuestionnaireDataUsersResult {
        data = typeof data === 'object' ? data : {};
        let result = new TrainerQuestionnaireDataUsersResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITrainerQuestionnaireDataUsersResult {
    status?: UsersResultStatus;
    content?: TrainerQuestionnaireData;
}

export class InsertTrainerSurveyRequestData implements IInsertTrainerSurveyRequestData {
    trainerInvitationId?: number;
    trainerQuestionnaireId?: number;
    grade?: number;
    answers?: number[] | undefined;

    constructor(data?: IInsertTrainerSurveyRequestData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainerInvitationId = _data["trainerInvitationId"];
            this.trainerQuestionnaireId = _data["trainerQuestionnaireId"];
            this.grade = _data["grade"];
            if (Array.isArray(_data["answers"])) {
                this.answers = [] as any;
                for (let item of _data["answers"])
                    this.answers!.push(item);
            }
        }
    }

    static fromJS(data: any): InsertTrainerSurveyRequestData {
        data = typeof data === 'object' ? data : {};
        let result = new InsertTrainerSurveyRequestData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainerInvitationId"] = this.trainerInvitationId;
        data["trainerQuestionnaireId"] = this.trainerQuestionnaireId;
        data["grade"] = this.grade;
        if (Array.isArray(this.answers)) {
            data["answers"] = [];
            for (let item of this.answers)
                data["answers"].push(item);
        }
        return data;
    }
}

export interface IInsertTrainerSurveyRequestData {
    trainerInvitationId?: number;
    trainerQuestionnaireId?: number;
    grade?: number;
    answers?: number[] | undefined;
}

export class TrainerWorkExperienceData implements ITrainerWorkExperienceData {
    id?: number;
    from?: Date;
    to?: Date | undefined;
    institution?: string | undefined;
    workplace?: string | undefined;
    trainerId?: number;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;

    constructor(data?: ITrainerWorkExperienceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.from = _data["from"] ? new Date(_data["from"].toString()) : <any>undefined;
            this.to = _data["to"] ? new Date(_data["to"].toString()) : <any>undefined;
            this.institution = _data["institution"];
            this.workplace = _data["workplace"];
            this.trainerId = _data["trainerId"];
            this.userIdIns = _data["userIdIns"];
            this.timeIns = _data["timeIns"] ? new Date(_data["timeIns"].toString()) : <any>undefined;
            this.userIdChg = _data["userIdChg"];
            this.timeChg = _data["timeChg"] ? new Date(_data["timeChg"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainerWorkExperienceData {
        data = typeof data === 'object' ? data : {};
        let result = new TrainerWorkExperienceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["from"] = this.from ? this.from.toISOString() : <any>undefined;
        data["to"] = this.to ? this.to.toISOString() : <any>undefined;
        data["institution"] = this.institution;
        data["workplace"] = this.workplace;
        data["trainerId"] = this.trainerId;
        data["userIdIns"] = this.userIdIns;
        data["timeIns"] = this.timeIns ? this.timeIns.toISOString() : <any>undefined;
        data["userIdChg"] = this.userIdChg;
        data["timeChg"] = this.timeChg ? this.timeChg.toISOString() : <any>undefined;
        return data;
    }
}

export interface ITrainerWorkExperienceData {
    id?: number;
    from?: Date;
    to?: Date | undefined;
    institution?: string | undefined;
    workplace?: string | undefined;
    trainerId?: number;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
}

export class TrainerWorkExperienceDataPagedModel implements ITrainerWorkExperienceDataPagedModel {
    totalItems?: number;
    items?: TrainerWorkExperienceData[] | undefined;

    constructor(data?: ITrainerWorkExperienceDataPagedModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItems = _data["totalItems"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TrainerWorkExperienceData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TrainerWorkExperienceDataPagedModel {
        data = typeof data === 'object' ? data : {};
        let result = new TrainerWorkExperienceDataPagedModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItems"] = this.totalItems;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITrainerWorkExperienceDataPagedModel {
    totalItems?: number;
    items?: TrainerWorkExperienceData[] | undefined;
}

export class TrainerWorkExperienceDataPagedModelUsersResult implements ITrainerWorkExperienceDataPagedModelUsersResult {
    status?: UsersResultStatus;
    content?: TrainerWorkExperienceDataPagedModel;

    constructor(data?: ITrainerWorkExperienceDataPagedModelUsersResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.content = _data["content"] ? TrainerWorkExperienceDataPagedModel.fromJS(_data["content"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainerWorkExperienceDataPagedModelUsersResult {
        data = typeof data === 'object' ? data : {};
        let result = new TrainerWorkExperienceDataPagedModelUsersResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITrainerWorkExperienceDataPagedModelUsersResult {
    status?: UsersResultStatus;
    content?: TrainerWorkExperienceDataPagedModel;
}

export class TrainerWorkExperienceDataUsersResult implements ITrainerWorkExperienceDataUsersResult {
    status?: UsersResultStatus;
    content?: TrainerWorkExperienceData;

    constructor(data?: ITrainerWorkExperienceDataUsersResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.content = _data["content"] ? TrainerWorkExperienceData.fromJS(_data["content"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainerWorkExperienceDataUsersResult {
        data = typeof data === 'object' ? data : {};
        let result = new TrainerWorkExperienceDataUsersResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITrainerWorkExperienceDataUsersResult {
    status?: UsersResultStatus;
    content?: TrainerWorkExperienceData;
}

export class LoginRequestData implements ILoginRequestData {
    username?: string | undefined;
    password?: string | undefined;
    applicationId?: number | undefined;

    constructor(data?: ILoginRequestData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.password = _data["password"];
            this.applicationId = _data["applicationId"];
        }
    }

    static fromJS(data: any): LoginRequestData {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequestData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        data["applicationId"] = this.applicationId;
        return data;
    }
}

export interface ILoginRequestData {
    username?: string | undefined;
    password?: string | undefined;
    applicationId?: number | undefined;
}

export enum SecurityResultStatus {
    Success = "Success",
    ServerError = "ServerError",
    ArgumentsException = "ArgumentsException",
    NotFound = "NotFound",
    WrongCreditials = "WrongCreditials",
    UserNotValidated = "UserNotValidated",
    Error = "Error",
    NotAuthenticated = "NotAuthenticated",
    InvalidToken = "InvalidToken",
    TokenAlreadyRefreshed = "TokenAlreadyRefreshed",
    TokenExpired = "TokenExpired",
    SuccessWithRefresh = "SuccessWithRefresh",
    EmailNotVerified = "EmailNotVerified",
    UserDisabled = "UserDisabled",
    InvalidUser = "InvalidUser",
    VerificationCodeExpired = "VerificationCodeExpired",
    InvalidVerificationCode = "InvalidVerificationCode",
}

export class LoginUserData implements ILoginUserData {
    name?: string | undefined;
    surname?: string | undefined;
    accessToken?: string | undefined;
    accessTokenValidTo?: Date;
    roleId?: number | undefined;

    constructor(data?: ILoginUserData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.accessToken = _data["accessToken"];
            this.accessTokenValidTo = _data["accessTokenValidTo"] ? new Date(_data["accessTokenValidTo"].toString()) : <any>undefined;
            this.roleId = _data["roleId"];
        }
    }

    static fromJS(data: any): LoginUserData {
        data = typeof data === 'object' ? data : {};
        let result = new LoginUserData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["accessToken"] = this.accessToken;
        data["accessTokenValidTo"] = this.accessTokenValidTo ? this.accessTokenValidTo.toISOString() : <any>undefined;
        data["roleId"] = this.roleId;
        return data;
    }
}

export interface ILoginUserData {
    name?: string | undefined;
    surname?: string | undefined;
    accessToken?: string | undefined;
    accessTokenValidTo?: Date;
    roleId?: number | undefined;
}

export class LoginUserDataSecurityResult implements ILoginUserDataSecurityResult {
    status?: SecurityResultStatus;
    content?: LoginUserData;

    constructor(data?: ILoginUserDataSecurityResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.content = _data["content"] ? LoginUserData.fromJS(_data["content"]) : <any>undefined;
        }
    }

    static fromJS(data: any): LoginUserDataSecurityResult {
        data = typeof data === 'object' ? data : {};
        let result = new LoginUserDataSecurityResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        return data;
    }
}

export interface ILoginUserDataSecurityResult {
    status?: SecurityResultStatus;
    content?: LoginUserData;
}

export class ChangePasswordRequestData implements IChangePasswordRequestData {
    newPassword?: string | undefined;
    oldPassword?: string | undefined;

    constructor(data?: IChangePasswordRequestData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newPassword = _data["newPassword"];
            this.oldPassword = _data["oldPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordRequestData {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordRequestData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newPassword"] = this.newPassword;
        data["oldPassword"] = this.oldPassword;
        return data;
    }
}

export interface IChangePasswordRequestData {
    newPassword?: string | undefined;
    oldPassword?: string | undefined;
}

export class ForgotPasswordRequestData implements IForgotPasswordRequestData {
    email?: string | undefined;

    constructor(data?: IForgotPasswordRequestData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ForgotPasswordRequestData {
        data = typeof data === 'object' ? data : {};
        let result = new ForgotPasswordRequestData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }
}

export interface IForgotPasswordRequestData {
    email?: string | undefined;
}

export class ResetPasswordRequestData implements IResetPasswordRequestData {
    userId?: number;
    verificationCodeId?: number;
    verificationCode?: string | undefined;
    newPassword?: string | undefined;

    constructor(data?: IResetPasswordRequestData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.verificationCodeId = _data["verificationCodeId"];
            this.verificationCode = _data["verificationCode"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordRequestData {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordRequestData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["verificationCodeId"] = this.verificationCodeId;
        data["verificationCode"] = this.verificationCode;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IResetPasswordRequestData {
    userId?: number;
    verificationCodeId?: number;
    verificationCode?: string | undefined;
    newPassword?: string | undefined;
}

export class ParticipantRegistrationData implements IParticipantRegistrationData {
    name?: string | undefined;
    surname?: string | undefined;
    birthdate?: Date | undefined;
    birthplace?: string | undefined;
    address?: string | undefined;
    email?: string | undefined;
    username?: string | undefined;
    embg?: string | undefined;
    phone?: string | undefined;
    institutionId?: number;
    cityId?: number;
    agreed?: boolean;
    languageId?: number;

    constructor(data?: IParticipantRegistrationData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.birthdate = _data["birthdate"] ? new Date(_data["birthdate"].toString()) : <any>undefined;
            this.birthplace = _data["birthplace"];
            this.address = _data["address"];
            this.email = _data["email"];
            this.username = _data["username"];
            this.embg = _data["embg"];
            this.phone = _data["phone"];
            this.institutionId = _data["institutionId"];
            this.cityId = _data["cityId"];
            this.agreed = _data["agreed"];
            this.languageId = _data["languageId"];
        }
    }

    static fromJS(data: any): ParticipantRegistrationData {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipantRegistrationData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["birthdate"] = this.birthdate ? this.birthdate.toISOString() : <any>undefined;
        data["birthplace"] = this.birthplace;
        data["address"] = this.address;
        data["email"] = this.email;
        data["username"] = this.username;
        data["embg"] = this.embg;
        data["phone"] = this.phone;
        data["institutionId"] = this.institutionId;
        data["cityId"] = this.cityId;
        data["agreed"] = this.agreed;
        data["languageId"] = this.languageId;
        return data;
    }
}

export interface IParticipantRegistrationData {
    name?: string | undefined;
    surname?: string | undefined;
    birthdate?: Date | undefined;
    birthplace?: string | undefined;
    address?: string | undefined;
    email?: string | undefined;
    username?: string | undefined;
    embg?: string | undefined;
    phone?: string | undefined;
    institutionId?: number;
    cityId?: number;
    agreed?: boolean;
    languageId?: number;
}

export class ParticipantProfileData implements IParticipantProfileData {
    id?: number;
    email?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    username?: string | undefined;
    embg?: string | undefined;
    identificationNumber?: number | undefined;
    phone?: string | undefined;
    cityId?: number | undefined;
    institutionId?: number;
    userId?: number;
    roleId?: number;
    address?: string | undefined;
    description?: string | undefined;
    birthdate?: Date | undefined;
    birthplace?: string | undefined;
    languageId?: number;
    idPrivacyPolicy?: number;
    agreed?: boolean;
    isClientIPInternal?: boolean;

    constructor(data?: IParticipantProfileData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.email = _data["email"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.username = _data["username"];
            this.embg = _data["embg"];
            this.identificationNumber = _data["identificationNumber"];
            this.phone = _data["phone"];
            this.cityId = _data["cityId"];
            this.institutionId = _data["institutionId"];
            this.userId = _data["userId"];
            this.roleId = _data["roleId"];
            this.address = _data["address"];
            this.description = _data["description"];
            this.birthdate = _data["birthdate"] ? new Date(_data["birthdate"].toString()) : <any>undefined;
            this.birthplace = _data["birthplace"];
            this.languageId = _data["languageId"];
            this.idPrivacyPolicy = _data["idPrivacyPolicy"];
            this.agreed = _data["agreed"];
            this.isClientIPInternal = _data["isClientIPInternal"];
        }
    }

    static fromJS(data: any): ParticipantProfileData {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipantProfileData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["email"] = this.email;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["username"] = this.username;
        data["embg"] = this.embg;
        data["identificationNumber"] = this.identificationNumber;
        data["phone"] = this.phone;
        data["cityId"] = this.cityId;
        data["institutionId"] = this.institutionId;
        data["userId"] = this.userId;
        data["roleId"] = this.roleId;
        data["address"] = this.address;
        data["description"] = this.description;
        data["birthdate"] = this.birthdate ? this.birthdate.toISOString() : <any>undefined;
        data["birthplace"] = this.birthplace;
        data["languageId"] = this.languageId;
        data["idPrivacyPolicy"] = this.idPrivacyPolicy;
        data["agreed"] = this.agreed;
        data["isClientIPInternal"] = this.isClientIPInternal;
        return data;
    }
}

export interface IParticipantProfileData {
    id?: number;
    email?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    username?: string | undefined;
    embg?: string | undefined;
    identificationNumber?: number | undefined;
    phone?: string | undefined;
    cityId?: number | undefined;
    institutionId?: number;
    userId?: number;
    roleId?: number;
    address?: string | undefined;
    description?: string | undefined;
    birthdate?: Date | undefined;
    birthplace?: string | undefined;
    languageId?: number;
    idPrivacyPolicy?: number;
    agreed?: boolean;
    isClientIPInternal?: boolean;
}

export class ParticipantProfileDataUsersResult implements IParticipantProfileDataUsersResult {
    status?: UsersResultStatus;
    content?: ParticipantProfileData;

    constructor(data?: IParticipantProfileDataUsersResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.content = _data["content"] ? ParticipantProfileData.fromJS(_data["content"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ParticipantProfileDataUsersResult {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipantProfileDataUsersResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        return data;
    }
}

export interface IParticipantProfileDataUsersResult {
    status?: UsersResultStatus;
    content?: ParticipantProfileData;
}

export class TrainerProfileData implements ITrainerProfileData {
    id?: number;
    name?: string | undefined;
    surname?: string | undefined;
    username?: string | undefined;
    birthDate?: Date;
    birthPlace?: string | undefined;
    address?: string | undefined;
    identificationNumber?: number | undefined;
    phone?: string | undefined;
    bankAccount?: string | undefined;
    bjNemployee?: boolean;
    institutionId?: number;
    workPosition?: string | undefined;
    cityId?: number | undefined;
    roleId?: number;
    userId?: number;
    idPrivacyPolicy?: number;
    agreed?: boolean;
    active?: boolean;
    email?: string | undefined;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
    trainerActive?: boolean;

    constructor(data?: ITrainerProfileData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.username = _data["username"];
            this.birthDate = _data["birthDate"] ? new Date(_data["birthDate"].toString()) : <any>undefined;
            this.birthPlace = _data["birthPlace"];
            this.address = _data["address"];
            this.identificationNumber = _data["identificationNumber"];
            this.phone = _data["phone"];
            this.bankAccount = _data["bankAccount"];
            this.bjNemployee = _data["bjNemployee"];
            this.institutionId = _data["institutionId"];
            this.workPosition = _data["workPosition"];
            this.cityId = _data["cityId"];
            this.roleId = _data["roleId"];
            this.userId = _data["userId"];
            this.idPrivacyPolicy = _data["idPrivacyPolicy"];
            this.agreed = _data["agreed"];
            this.active = _data["active"];
            this.email = _data["email"];
            this.userIdIns = _data["userIdIns"];
            this.timeIns = _data["timeIns"] ? new Date(_data["timeIns"].toString()) : <any>undefined;
            this.userIdChg = _data["userIdChg"];
            this.timeChg = _data["timeChg"] ? new Date(_data["timeChg"].toString()) : <any>undefined;
            this.trainerActive = _data["trainerActive"];
        }
    }

    static fromJS(data: any): TrainerProfileData {
        data = typeof data === 'object' ? data : {};
        let result = new TrainerProfileData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["username"] = this.username;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["birthPlace"] = this.birthPlace;
        data["address"] = this.address;
        data["identificationNumber"] = this.identificationNumber;
        data["phone"] = this.phone;
        data["bankAccount"] = this.bankAccount;
        data["bjNemployee"] = this.bjNemployee;
        data["institutionId"] = this.institutionId;
        data["workPosition"] = this.workPosition;
        data["cityId"] = this.cityId;
        data["roleId"] = this.roleId;
        data["userId"] = this.userId;
        data["idPrivacyPolicy"] = this.idPrivacyPolicy;
        data["agreed"] = this.agreed;
        data["active"] = this.active;
        data["email"] = this.email;
        data["userIdIns"] = this.userIdIns;
        data["timeIns"] = this.timeIns ? this.timeIns.toISOString() : <any>undefined;
        data["userIdChg"] = this.userIdChg;
        data["timeChg"] = this.timeChg ? this.timeChg.toISOString() : <any>undefined;
        data["trainerActive"] = this.trainerActive;
        return data;
    }
}

export interface ITrainerProfileData {
    id?: number;
    name?: string | undefined;
    surname?: string | undefined;
    username?: string | undefined;
    birthDate?: Date;
    birthPlace?: string | undefined;
    address?: string | undefined;
    identificationNumber?: number | undefined;
    phone?: string | undefined;
    bankAccount?: string | undefined;
    bjNemployee?: boolean;
    institutionId?: number;
    workPosition?: string | undefined;
    cityId?: number | undefined;
    roleId?: number;
    userId?: number;
    idPrivacyPolicy?: number;
    agreed?: boolean;
    active?: boolean;
    email?: string | undefined;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
    trainerActive?: boolean;
}

export class TrainerProfileDataUsersResult implements ITrainerProfileDataUsersResult {
    status?: UsersResultStatus;
    content?: TrainerProfileData;

    constructor(data?: ITrainerProfileDataUsersResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.content = _data["content"] ? TrainerProfileData.fromJS(_data["content"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainerProfileDataUsersResult {
        data = typeof data === 'object' ? data : {};
        let result = new TrainerProfileDataUsersResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITrainerProfileDataUsersResult {
    status?: UsersResultStatus;
    content?: TrainerProfileData;
}

export class CommissionProfileData implements ICommissionProfileData {
    id?: number;
    name?: string | undefined;
    surname?: string | undefined;
    username?: string | undefined;
    birthdate?: Date | undefined;
    address?: string | undefined;
    identificationNumber?: number | undefined;
    phone?: string | undefined;
    bankAccount?: string | undefined;
    bjnEmployee?: boolean;
    institutionId?: number;
    workPosition?: string | undefined;
    cityId?: number | undefined;
    roleId?: number;
    userId?: number;
    active?: boolean;
    email?: string | undefined;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
    commissionActive?: boolean;

    constructor(data?: ICommissionProfileData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.username = _data["username"];
            this.birthdate = _data["birthdate"] ? new Date(_data["birthdate"].toString()) : <any>undefined;
            this.address = _data["address"];
            this.identificationNumber = _data["identificationNumber"];
            this.phone = _data["phone"];
            this.bankAccount = _data["bankAccount"];
            this.bjnEmployee = _data["bjnEmployee"];
            this.institutionId = _data["institutionId"];
            this.workPosition = _data["workPosition"];
            this.cityId = _data["cityId"];
            this.roleId = _data["roleId"];
            this.userId = _data["userId"];
            this.active = _data["active"];
            this.email = _data["email"];
            this.userIdIns = _data["userIdIns"];
            this.timeIns = _data["timeIns"] ? new Date(_data["timeIns"].toString()) : <any>undefined;
            this.userIdChg = _data["userIdChg"];
            this.timeChg = _data["timeChg"] ? new Date(_data["timeChg"].toString()) : <any>undefined;
            this.commissionActive = _data["commissionActive"];
        }
    }

    static fromJS(data: any): CommissionProfileData {
        data = typeof data === 'object' ? data : {};
        let result = new CommissionProfileData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["username"] = this.username;
        data["birthdate"] = this.birthdate ? this.birthdate.toISOString() : <any>undefined;
        data["address"] = this.address;
        data["identificationNumber"] = this.identificationNumber;
        data["phone"] = this.phone;
        data["bankAccount"] = this.bankAccount;
        data["bjnEmployee"] = this.bjnEmployee;
        data["institutionId"] = this.institutionId;
        data["workPosition"] = this.workPosition;
        data["cityId"] = this.cityId;
        data["roleId"] = this.roleId;
        data["userId"] = this.userId;
        data["active"] = this.active;
        data["email"] = this.email;
        data["userIdIns"] = this.userIdIns;
        data["timeIns"] = this.timeIns ? this.timeIns.toISOString() : <any>undefined;
        data["userIdChg"] = this.userIdChg;
        data["timeChg"] = this.timeChg ? this.timeChg.toISOString() : <any>undefined;
        data["commissionActive"] = this.commissionActive;
        return data;
    }
}

export interface ICommissionProfileData {
    id?: number;
    name?: string | undefined;
    surname?: string | undefined;
    username?: string | undefined;
    birthdate?: Date | undefined;
    address?: string | undefined;
    identificationNumber?: number | undefined;
    phone?: string | undefined;
    bankAccount?: string | undefined;
    bjnEmployee?: boolean;
    institutionId?: number;
    workPosition?: string | undefined;
    cityId?: number | undefined;
    roleId?: number;
    userId?: number;
    active?: boolean;
    email?: string | undefined;
    userIdIns?: number | undefined;
    timeIns?: Date | undefined;
    userIdChg?: number | undefined;
    timeChg?: Date | undefined;
    commissionActive?: boolean;
}

export class CommissionProfileDataUsersResult implements ICommissionProfileDataUsersResult {
    status?: UsersResultStatus;
    content?: CommissionProfileData;

    constructor(data?: ICommissionProfileDataUsersResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.content = _data["content"] ? CommissionProfileData.fromJS(_data["content"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CommissionProfileDataUsersResult {
        data = typeof data === 'object' ? data : {};
        let result = new CommissionProfileDataUsersResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICommissionProfileDataUsersResult {
    status?: UsersResultStatus;
    content?: CommissionProfileData;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}